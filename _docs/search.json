[
  {
    "objectID": "03_Gpt_Solution.html",
    "href": "03_Gpt_Solution.html",
    "title": "GPT Solution",
    "section": "",
    "text": "openai.api_key = os.getenv(\"OPENAI_API_KEY\")"
  },
  {
    "objectID": "03_Gpt_Solution.html#configuring-openai-credentials",
    "href": "03_Gpt_Solution.html#configuring-openai-credentials",
    "title": "GPT Solution",
    "section": "",
    "text": "openai.api_key = os.getenv(\"OPENAI_API_KEY\")"
  },
  {
    "objectID": "03_Gpt_Solution.html#gptprompt",
    "href": "03_Gpt_Solution.html#gptprompt",
    "title": "GPT Solution",
    "section": "GptPrompt",
    "text": "GptPrompt\n\nClass For sending messages to Open AI  \n\nSimple class to make reusing a prompt easier\n\nclass GptPrompt:\n    def __init__(self, messages):\n        self.messages = messages\n\n    def add_data(self, data): \n        messages = self.messages[:]\n\n        messages.append({\n          \"role\": \"user\",\n          \"content\": data\n        })\n        \n        return messages\n    \n    def call_gpt(self, data, model=\"gpt-3.5-turbo-16k-0613\"):\n        response = openai.ChatCompletion.create(\n            model=model, \n            messages=self.add_data(data),\n            temperature=.1,\n            max_tokens=11520,\n            top_p=.5,\n            frequency_penalty=0,\n            presence_penalty=0\n        )\n\n        return json.loads(response.choices[0]['message']['content'])\n\n\nsource\n\nGptPrompt\n\n GptPrompt (messages)\n\nInitialize self. See help(type(self)) for accurate signature."
  },
  {
    "objectID": "03_Gpt_Solution.html#creditcardtype",
    "href": "03_Gpt_Solution.html#creditcardtype",
    "title": "GPT Solution",
    "section": "CreditCardType",
    "text": "CreditCardType\n\nCan only be Visa, Mastercard, AMEX, Discover  - Solution:  - Asking Chat GPT to format the unique CreditCardTypes into the pre-approved list of values \n\n\ncredit_card_prompt =[ \n    {\n      \"role\": \"system\",\n      \"content\": \"\"\"\n      You will be given a comma separated list of items. \n      Each item is supposed to be a unique credit card type taken from a column on a database table. \n      The only acceptable credit card types are [Visa, Mastercard, AMEX, Discover]\n      Your job is to examine each item in the list to see if it matches one of the acceptable credit card types or not.\n      For each item in the list that is not ALREADY in the list of acceptable credit card types you will need to provide which credit card type it matches with. \n      If a item doesn't match ANY of the acceptable credit card types [Visa, Mastercard, AMEX, Discover] then match it with an empty string ''\n      Format your response in JSON\n      \"\"\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Americn Ex,AMEX,Visa,Master car,Mastercard,Discover,Jazz\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"\"\"{\n              \"Americn Ex\": \"AMEX\",\n              \"Master car\": \"Mastercard\",\n              \"Jazz\":\"\"\n          }\n          \"\"\"\n    },\n]\n\n\nCreditCardCleaner = GptPrompt(messages=credit_card_prompt)\n\n\nvalues_to_replace = CreditCardCleaner.call_gpt(to_csl(gifts['CreditCardType']))\n\n\nvalues_to_replace\n\n{'American Ex': 'AMEX', 'Master card': 'Mastercard', '': ''}\n\n\n\ngifts['CreditCardType'] = gifts['CreditCardType'].replace(values_to_replace)"
  },
  {
    "objectID": "03_Gpt_Solution.html#gifttype",
    "href": "03_Gpt_Solution.html#gifttype",
    "title": "GPT Solution",
    "section": "GiftType",
    "text": "GiftType\n\nCan only be Cash, Check, Credit, Other, or Reversing Transaction   - Solution:  - Asking Chat GPT to format the unique GiftTypes into the pre-approved list of values  - Replace ‘Reversing Transaction’ using simple logic in Python \n\n\ngift_type_prompt = [\n        {\n          \"role\": \"system\",\n          \"content\": \"\"\"\n          You will be given a comma separated list of items. \n          Each item is supposed to be a unique payment method taken from a column on a database table. \n          The only acceptable payment methods are [Cash, Check, Credit, or Other]\n          Your job is to examine each item in the list to see if it matches one of the acceptable payment methods or not. If it doesn't map to \n          For each item in the list that is not ALREADY in the list of acceptable payment method  you will need to provide which payment method  type it matches with\n          Format your response in JSON\n          \"\"\"\n        },\n        {\n          \"role\": \"user\",\n          \"content\": \"$,cash,Credit,AMEX,Square\"\n        },\n        {\n          \"role\": \"assistant\",\n          \"content\": \"\"\"{\n                  \"$: \"Cash\",\n                  \"cash: \"Cash\",\n                  \"AMEX\":\"Credit\",\n                  \"Square\":\"Other\",\n                  \n              }\n              \"\"\"\n        },\n      ]\n\n\nGiftTypeCleaner = GptPrompt(messages=gift_type_prompt)\n\n\nvalues_to_replace = GiftTypeCleaner.call_gpt(to_csl(gifts['PaymentMethod']))\nvalues_to_replace[''] = 'Other'\n\n\nvalues_to_replace\n\n{'PayPal': 'Other',\n 'check': 'Check',\n 'cash': 'Cash',\n 'credit card': 'Credit',\n 'money order': 'Other',\n '': 'Other'}\n\n\n\ngifts.apply(lambda row: 'Reversing Transaction' if row['AmountReceived'] &lt; 0 else values_to_replace[row['PaymentMethod']], axis=1)\n\n0                     Other\n1                     Check\n2                      Cash\n3                    Credit\n4                      Cash\n5                     Other\n6                     Check\n7                     Check\n8                     Check\n9                    Credit\n10                   Credit\n11                    Other\n12                    Check\n13    Reversing Transaction\n14                    Other\n15                    Other\n16                     Cash\n17                    Other\n18                    Other\n19                    Other\n20                    Check\n21                   Credit\n22                     Cash\n23                    Other\n24                    Other\n25                     Cash\n26    Reversing Transaction\n27                   Credit\n28                     Cash\n29                    Other\n30                   Credit\ndtype: object"
  },
  {
    "objectID": "03_Gpt_Solution.html#contacttype",
    "href": "03_Gpt_Solution.html#contacttype",
    "title": "GPT Solution",
    "section": "ContactType",
    "text": "ContactType\n`is required and can only be Household or Organization   - Source Table: Contacts Table  - Solution:  - Create procedure to add new column ContactType \n\ndf = contacts.copy()\ngpt_response = df.ask(\"create a new column called ContactType. The value is required and can only be either Household or Organization. If CompanyName is '' assume it's a household\")\ngpt_response[['Number', 'CompanyName', 'ContactType']].head(5)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nContactType\n\n\n\n\n0\n653377813-7\n\nHousehold\n\n\n1\n390551098-7\n\nHousehold\n\n\n2\n093004505-X\n\nHousehold\n\n\n3\n729707142-0\nA Company Co.\nOrganization\n\n\n4\n488464926-5\n\nHousehold"
  },
  {
    "objectID": "03_Gpt_Solution.html#postal-code",
    "href": "03_Gpt_Solution.html#postal-code",
    "title": "GPT Solution",
    "section": "Postal Code",
    "text": "Postal Code\n\nif address is present and is US, must be a valid zip code, either 12345 or 12345-1234   - Source Table: Contacts - Solution: - Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\n\ncontacts[['Postal']]\n\n\n\n\n\n\n\n\nPostal\n\n\n\n\n0\n20535-871\n\n\n1\n89130\n\n\n2\n\n\n\n3\n8104\n\n\n4\n49560\n\n\n5\n837016\n\n\n6\n\n\n\n7\n30066\n\n\n8\n68164\n\n\n9\n\n\n\n10\n\n\n\n\n\n\n\n\n\ndf = contacts.copy()\ngpt_response = df.ask(\"Clean the Postal Column. If address is present and is US, must be a valid zip code, either 12345 or 12345-1234. Don't delete rows with an invalid zip, just replace the invalid zip with ''\")\ngpt_response[['Postal']]\n\n\n\n\n\n\n\n\nPostal\n\n\n\n\n0\n\n\n\n1\n89130\n\n\n2\n\n\n\n3\n\n\n\n4\n49560\n\n\n5\n\n\n\n6\n\n\n\n7\n30066\n\n\n8\n68164\n\n\n9\n\n\n\n10"
  },
  {
    "objectID": "03_Gpt_Solution.html#isdeceased",
    "href": "03_Gpt_Solution.html#isdeceased",
    "title": "GPT Solution",
    "section": "IsDeceased",
    "text": "IsDeceased\n\ncan only be TRUE or FALSE   - Source Table: Contacts  - Solution:  - Create procedure to update Deceased to TRUE/FALSE \n\n\ngpt_response.Deceased.unique()\n\narray(['', 'No', 'Yes'], dtype=object)\n\n\n\ndf = contacts.copy()\ngpt_response = df.ask('Can you convert the Deceased column to a boolean. Assume empty strings '' are False')\ngpt_response.Deceased.unique()\n\narray([False,  True])"
  },
  {
    "objectID": "01_SQL_Solution.html",
    "href": "01_SQL_Solution.html",
    "title": "SQL Solution",
    "section": "",
    "text": "load_dotenv()\n\nTrue"
  },
  {
    "objectID": "01_SQL_Solution.html#creating-db",
    "href": "01_SQL_Solution.html#creating-db",
    "title": "SQL Solution",
    "section": "Creating DB",
    "text": "Creating DB\nexam_db\n\nDB_NAME = 'exam_db'\n\nUsing mysql library to connect as root user and create a new db instance\n\ntry:\n    connection = mysql.connector.connect(user='root', host='localhost')\n    cursor = connection.cursor()\n    cursor.execute(f\"CREATE DATABASE IF NOT EXISTS {DB_NAME};\")\nexcept Error as e:\n    print(f\"Error: {e}\")\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()\n\nSince that was a lot of code just to execute 1 line of SQL, I’m going to create a new function that will make it easier\n\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\n\n\ndef insert_sql(sql):\n    try:\n        # Connect to MySQL\n        connection = mysql.connector.connect(user=DB_USER, password=DB_PASSWORD, host='localhost', database=DB_NAME)\n        cursor = connection.cursor()\n    \n        # Execute the SQL command to create the view\n        cursor.execute(sql)\n        print(\"SQL executed successfully\")\n    \n    except Error as e:\n        print(f\"Error: {e}\")\n    \n    finally:\n        if connection.is_connected():\n            cursor.close()\n            connection.close()\n        print(\"MySQL connection closed\")\n\n\nsource\n\ninsert_sql\n\n insert_sql (sql)\n\n  Since I’m going to be writing a lot of basic procedures as well, I’m going to create a function that will make it a little bit easier\n\ndef insert_proc(sql, proc_name, call=True):\n    insert_sql(f'DROP PROCEDURE IF EXISTS {proc_name};')\n    stmt = f\"\"\"         \n        CREATE PROCEDURE {proc_name}()\n        BEGIN\n            {sql}\n        END;\n        COMMIT;\n    \"\"\"\n    insert_sql(stmt)\n    if call:\n        insert_sql(f'CALL {proc_name}();')\n\n\nsource\n\n\ninsert_proc\n\n insert_proc (sql, proc_name, call=True)"
  },
  {
    "objectID": "01_SQL_Solution.html#loading-datasets-into-database",
    "href": "01_SQL_Solution.html#loading-datasets-into-database",
    "title": "SQL Solution",
    "section": "Loading Datasets Into Database",
    "text": "Loading Datasets Into Database\n\nUsing prefix ‘temp_’\n\nMapping DataFrames to table names\n\ntables = {'temp_contact_methods': contact_methods, 'temp_contacts': contacts, 'temp_gifts': gifts}\n\n\nengine = create_engine(f'mysql+mysqlconnector://{DB_USER}:{DB_PASSWORD}@localhost/{DB_NAME}')\n\n\ntry:\n    for table_name, df in tables.items():\n        try:\n            df.to_sql(table_name, engine, index=False, if_exists='fail')\n        except ValueError:\n            print(f\"Table {table_name} already exists. Skipping.\")\n\nexcept Error as e:\n    print(f\"Error: {e}\")\n\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()\n\nTable temp_contact_methods already exists. Skipping.\nTable temp_contacts already exists. Skipping.\nTable temp_gifts already exists. Skipping.\n\n\nPreviewing the data"
  },
  {
    "objectID": "01_SQL_Solution.html#contacttype",
    "href": "01_SQL_Solution.html#contacttype",
    "title": "SQL Solution",
    "section": "ContactType",
    "text": "ContactType\n\nis required and can only be Household or Organization  - Source Table: Contacts Table - Solution: - Create procedure to add new column ContactType\n\nNow I’m going to write a procedure that would perform this transformation on the temp table.   Since it’s possible that I may need to run this procedure multiple times, each time the data is updated I’m going to write 2 procedures to solve this problem   1. Add column procedure - Add a column if it doesn’t exist 2. Procedure to add ContactType\n\nadd_column = \"\"\"\n    DROP PROCEDURE IF EXISTS add_column;\n    \n    \n    CREATE PROCEDURE add_column(\n        IN tableName VARCHAR(255),\n        IN columnName VARCHAR(255),\n        IN columnType VARCHAR(255)\n    )\n    BEGIN\n        DECLARE columnExists BOOLEAN DEFAULT FALSE;\n    \n        SELECT COUNT(*)\n        INTO columnExists\n        FROM information_schema.COLUMNS\n        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = tableName AND COLUMN_NAME = columnName;\n    \n        IF columnExists = 0 THEN\n            SET @sql = CONCAT('ALTER TABLE ', tableName, ' ADD COLUMN ', columnName, ' ', columnType);\n            PREPARE stmt FROM @sql;\n            EXECUTE stmt;\n            DEALLOCATE PREPARE stmt;\n        END IF;\n        COMMIT;\n    END;\n\"\"\"\ninsert_sql(add_column)\n\nSQL executed successfully\nMySQL connection closed\n\n\n\ninsert_contact_type = \"\"\"\n    CALL add_column('temp_contacts', 'ContactType', 'VARCHAR(255)');\n    \n    UPDATE temp_contacts\n    SET ContactType = CASE WHEN CompanyName = '' THEN 'Household' ELSE 'Organization' END;\n    COMMIT;\n\"\"\"\ninsert_proc(insert_contact_type, 'insert_contact_type', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#private",
    "href": "01_SQL_Solution.html#private",
    "title": "SQL Solution",
    "section": "Private",
    "text": "Private\n\nDoes someone want to be private  - Source Table: Contacts Table - Solution: - Create procedure to add new column Private\n\n\ninsert_private = \"\"\"\n    CALL add_column('temp_contacts', 'Private', 'TINYINT');\n\n    UPDATE temp_contacts\n    SET Private = CASE WHEN Remarks = 'Is anonymous' THEN 1 ELSE 0 END;\n    commit;\n\"\"\"\ninsert_proc(insert_private, 'insert_private', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#postal-code",
    "href": "01_SQL_Solution.html#postal-code",
    "title": "SQL Solution",
    "section": "Postal Code",
    "text": "Postal Code\n\nif address is present and is US, must be a valid zip code, either 12345 or 12345-1234   - Source Table: Contacts - Solution: - Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\n\n','.join(contacts.columns.drop('Postal').tolist())\n\n'Number,CompanyName,FirstName,LastName,Street,City,State,Phone,EMail,Remarks,Deceased,SecondaryFirstName,SecondaryLastName,LegacyIndividualId,SecondaryLegacyIndividualId,ContactName'\n\n\n\ncontacts_view = f\"\"\"\n    CREATE OR REPLACE VIEW contacts_view AS\n    SELECT\n        NUMBER,\n        POSTAL AS OLD_POSTAL,\n        CASE\n        WHEN REGEXP_LIKE(Postal, '^[0-9]{{5}}$') OR REGEXP_LIKE(Postal, '^[0-9]{{5}}-[0-9]{{4}}$') THEN Postal\n        ELSE ''\n        END AS NEW_POSTAL\n    FROM temp_contacts;\n\"\"\"\ninsert_sql(contacts_view)\npd.read_sql(\"SELECT * FROM contacts_view where old_postal != '' limit 5\", con=engine)\n\nSQL executed successfully\nMySQL connection closed\n\n\n\n\n\n\n\n\n\nNUMBER\nOLD_POSTAL\nNEW_POSTAL\n\n\n\n\n0\n653377813-7\n20535-871\n\n\n\n1\n390551098-7\n89130\n89130\n\n\n2\n729707142-0\n8104\n\n\n\n3\n488464926-5\n49560\n49560\n\n\n4\n315297729-8\n837016\n\n\n\n\n\n\n\n\nSuccess!  Creating Stored Procedure…\n\nupdate_zip = \"\"\"\n    UPDATE temp_contacts\n    SET Postal = ''\n    WHERE Postal NOT REGEXP '^[0-9]{5}$' AND Postal NOT REGEXP '^[0-9]{5}-[0-9]{4}$';\n    COMMIT;\n\"\"\"\ninsert_proc(update_zip, 'update_zip', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#isdeceased",
    "href": "01_SQL_Solution.html#isdeceased",
    "title": "SQL Solution",
    "section": "IsDeceased",
    "text": "IsDeceased\n\ncan only be TRUE or FALSE  - Source Table: Contacts  - Solution:  - Create procedure to update Deceased to TRUE/FALSE\n\n\nupdate_deceased = f\"\"\"\n    UPDATE temp_contacts\n    SET Deceased = CASE\n        WHEN Deceased = 'Yes' THEN 1\n        ELSE 0\n    END;\n    commit;\n    ALTER TABLE temp_contacts MODIFY Deceased TINYINT;\n    commit;\n\"\"\"\ninsert_proc(update_deceased, 'update_deceased', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nError: 1292 (22007): Truncated incorrect DOUBLE value: 'Yes'\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#gifttype",
    "href": "01_SQL_Solution.html#gifttype",
    "title": "SQL Solution",
    "section": "GiftType",
    "text": "GiftType\n\nCan only be Cash, Check, Credit, Other, or Reversing Transaction  - Source Table: Gifts - Solution: - Identify Incorrect Gift Types - Create procedure to replace invalid gift types\n\nIt looks like there are several payment methods that don’t match the approved list. Additionally, the payment method ‘credit card’ will need to be mapped to ‘credit’\n\nupdate_gift_type = f\"\"\"\n  UPDATE temp_gifts\n  SET PaymentMethod = CASE\n    WHEN AmountReceived &lt; 0 THEN 'Reversing Transaction'\n    WHEN LOWER(TRIM(PaymentMethod)) = 'cash' THEN 'Cash'\n    WHEN LOWER(TRIM(PaymentMethod)) = 'check' THEN 'Check'\n    WHEN LOWER(TRIM(PaymentMethod)) LIKE 'credit%' THEN 'Credit'\n    ELSE 'Other'\n  END;\n  commit;\n\"\"\"\ninsert_proc(update_gift_type, 'update_gift_type', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#creditcardtype",
    "href": "01_SQL_Solution.html#creditcardtype",
    "title": "SQL Solution",
    "section": "CreditCardType",
    "text": "CreditCardType\n\nCan only be Visa, Mastercard, AMEX, Discover   - Solution:  - Identify Incorrect Credit Types  - Create procedure to replace invalid credit types\n\n\nproc = f\"\"\"\nUPDATE temp_gifts\n    SET CreditCardType = CASE\n    WHEN CreditCardType  = 'Master card' THEN 'Mastercard'\n    else 'AMEX'\n    end\nWHERE CreditCardType IN ('American Ex', 'Master car');\ncommit;\n\"\"\"\ninsert_proc(proc, 'update_gift_type', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#contacts",
    "href": "01_SQL_Solution.html#contacts",
    "title": "SQL Solution",
    "section": "Contacts",
    "text": "Contacts\n\nCreating the final contacts table  \n\n\nThe cleaning is done \nCreating contacts table and renaming various columns \n\n\npd.read_sql('SELECT * FROM temp_contacts', engine)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\nContactName\nContactType\nPrivate\n\n\n\n\n0\n653377813-7\n\nKarita\nLumbers\n4 Bunting Parkway\nWashington\nDC\n\n\nkklumbers@yahoo.com\nIs anonymous\n0\nKelvin\nLumbers\n0\n1\nKarita & Kelvin Lumbers\nHousehold\n1\n\n\n1\n390551098-7\n\nHelga\nBenech\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n\nebenech1@goodreads.com\n\n0\n\n\n2\n\nHelga Benech\nHousehold\n0\n\n\n2\n093004505-X\n\nMasha\nButt Gow\n353 Schmedeman Park\nIndianapolis\nIN\n\n\n\n\n0\n\n\n3\n\nMasha Butt Gow\nHousehold\n0\n\n\n3\n729707142-0\nA Company Co.\nCymbre\nCross\n2055 Lakewood Parkway\nCamden\nNJ\n\n\n\n\n0\n\n\n4\n\nCymbre Cross\nOrganization\n0\n\n\n4\n488464926-5\n\nHoyt\nCastille\n37 8th Trail\nGrand Rapids\nMI\n49560\n\nfcastille4@timesonline.co.uk\n\n0\n\n\n5\n\nHoyt Castille\nHousehold\n0\n\n\n5\n315297729-8\n\nBenedict\nOscar\n4225 Madison Ave\nBoise\nID\n\n\n\n\n0\nIdell\nMouncey\n6\n7\nBenedict Oscar & Idell Mouncey\nHousehold\n0\n\n\n6\n848348568-0\n\nMannie\nTurpin\n\n\nNV\n\n702-844-9524\n\nMet in person on 5/9/2018 at Annual Event\n1\n\n\n8\n\nMannie Turpin\nHousehold\n0\n\n\n7\n029456846-8\n\nRomy\nDoley\n608 Old Shore Alley\nMarietta\nGA\n30066\n\njdoley6@telegraph.co.uk\n\n0\n\n\n9\n\nRomy Doley\nHousehold\n0\n\n\n8\n687119652-8\n\nRuggiero\nMakepeace\n15 Sunbrook Center\nOmaha\nNE\n68164\n\ncmakepeace7@1688.com\nElectronic receipt only\n0\n\n\n10\n\nRuggiero Makepeace\nHousehold\n0\n\n\n9\n739131380-7\n\nRosemaria\nDimond\n\nJuneau\nAK\n\n\n\n\n0\nRogelio\nDimond\n11\n12\nRosemaria & Rogelio Dimond\nHousehold\n0\n\n\n10\n809975531-Y\n\nAdeline\nShakespeare\n\n\n\n\n\n\n\n0\n\n\n13\n\nAdeline Shakespeare\nHousehold\n0\n\n\n\n\n\n\n\n\n\npd.read_sql(\"\"\"\n            SELECT \n                `Number`,\n                `LegacyIndividualId`,\n                `ContactType`\n                `ContactName`,\n                `FirstName`,\n                `LastName`\n                `SecondaryLegacyIndividualId`,\n                `SecondaryFirstName`,\n                `SecondaryLastName`,\n                CASE WHEN\n                    temp_contact_methods.`Phone`  = '' \n                    THEN temp_contacts.`Phone`\n                    ELSE temp_contact_methods.`Phone`\n                END AS HomePhone,\n                CASE WHEN\n                    temp_contact_methods.`EMail`  = ''\n                    THEN temp_contacts.`EMail`\n                    ELSE temp_contact_methods.`EMail`\n                END AS HomeEmail,\n                `Street`,\n                `City`,\n                `State`,\n                `Postal`,\n                `Private`,\n                `Deceased`\n            FROM \n            temp_contacts\n            LEFT JOIN\n                temp_contact_methods ON temp_contact_methods.DonorNumber = temp_contacts.`Number`;\n            \"\"\",\n            engine\n            )\n\n\n\n\n\n\n\n\nNumber\nLegacyIndividualId\nContactName\nFirstName\nSecondaryLegacyIndividualId\nSecondaryFirstName\nSecondaryLastName\nHomePhone\nHomeEmail\nStreet\nCity\nState\nPostal\nPrivate\nDeceased\n\n\n\n\n0\n653377813-7\n0\nHousehold\nKarita\nLumbers\nKelvin\nLumbers\n832-442-4988\nkklumbers@yahoo.com\n4 Bunting Parkway\nWashington\nDC\n\n1\n0\n\n\n1\n390551098-7\n2\nHousehold\nHelga\nBenech\n\n\n\nebenech1@goodreads.com\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n0\n0\n\n\n2\n093004505-X\n3\nHousehold\nMasha\nButt Gow\n\n\n818-323-9865\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n0\n0\n\n\n3\n729707142-0\n4\nOrganization\nCymbre\nCross\n\n\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n\n0\n0\n\n\n4\n488464926-5\n5\nHousehold\nHoyt\nCastille\n\n\n\nfcastille4@timesonline.co.uk\n37 8th Trail\nGrand Rapids\nMI\n49560\n0\n0\n\n\n5\n315297729-8\n6\nHousehold\nBenedict\nOscar\nIdell\nMouncey\n\ndmouncey9@cnn.com\n4225 Madison Ave\nBoise\nID\n\n0\n0\n\n\n6\n315297729-8\n6\nHousehold\nBenedict\nOscar\nIdell\nMouncey\n\n\n4225 Madison Ave\nBoise\nID\n\n0\n0\n\n\n7\n848348568-0\n8\nHousehold\nMannie\nTurpin\n\n\n702-844-9524\n\n\n\nNV\n\n0\n1\n\n\n8\n029456846-8\n9\nHousehold\nRomy\nDoley\n\n\n\njdoley6@telegraph.co.uk\n608 Old Shore Alley\nMarietta\nGA\n30066\n0\n0\n\n\n9\n687119652-8\n10\nHousehold\nRuggiero\nMakepeace\n\n\n\ncmakepeace7@1688.com\n15 Sunbrook Center\nOmaha\nNE\n68164\n0\n0\n\n\n10\n739131380-7\n11\nHousehold\nRosemaria\nDimond\nRogelio\nDimond\n\n\n\nJuneau\nAK\n\n0\n0\n\n\n11\n809975531-Y\n13\nHousehold\nAdeline\nShakespeare\n\n\nNone\nNone\n\n\n\n\n0\n0\n\n\n\n\n\n\n\n\n\nproc = \"\"\"\n\n\nCREATE TABLE IF NOT EXISTS contacts (\n    `LegacyContactId` VARCHAR(255),\n    `LegacyIndividualId` VARCHAR(255),\n    `ContactType` VARCHAR(255),\n    `ContactName` VARCHAR(255),\n    `FirstName` VARCHAR(255),\n    `LastName` VARCHAR(255),\n    `SecondaryLegacyIndividualId` VARCHAR(255),\n    `SecondaryFirstName` VARCHAR(255),\n    `SecondaryLastName` VARCHAR(255),\n    `HomePhone` VARCHAR(255),\n    `HomeEmail` VARCHAR(255),\n    `Address1` VARCHAR(255),\n    `City` VARCHAR(255),\n    `State` VARCHAR(255),\n    `PostalCode` VARCHAR(255),\n    `IsPrivate` VARCHAR(255),\n    `IsDeceased` VARCHAR(255)\n);\ninsert into contacts\nSELECT \n    `Number` AS `LegacyContactId`,\n    `LegacyIndividualId`,\n    `ContactType`,\n    `ContactName`,\n    `FirstName`,\n    `LastName`,\n    `SecondaryLegacyIndividualId`,\n    `SecondaryFirstName`,\n    `SecondaryLastName`,\n    CASE WHEN\n        temp_contact_methods.`Phone`  = '' \n        THEN temp_contacts.`Phone`\n        ELSE temp_contact_methods.`Phone`\n    END AS HomePhone,\n    CASE WHEN\n        temp_contact_methods.`EMail`  = ''\n        THEN temp_contacts.`EMail`\n        ELSE temp_contact_methods.`EMail`\n    END AS HomeEmail,\n    `Street` AS `Address1`,\n    `City`,\n    `State`,\n    `Postal` AS `PostalCode`,\n    `Private` AS `IsPrivate`,\n    `Deceased` AS `IsDeceased`\nFROM \ntemp_contacts\nLEFT JOIN\n    temp_contact_methods ON temp_contact_methods.DonorNumber = temp_contacts.`Number`;\n    \ncommit;\n\"\"\"\ninsert_proc(proc, 'create_contacts', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\n\n\n\n\npd.read_sql('select * from contacts limit 5', engine)\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyIndividualId\nContactType\nContactName\nFirstName\nLastName\nSecondaryLegacyIndividualId\nSecondaryFirstName\nSecondaryLastName\nHomePhone\nHomeEmail\nAddress1\nCity\nState\nPostalCode\nIsPrivate\nIsDeceased\n\n\n\n\n0\n653377813-7\n0\nHousehold\nKarita & Kelvin Lumbers\nKarita\nLumbers\n1\nKelvin\nLumbers\n832-442-4988\nkklumbers@yahoo.com\n4 Bunting Parkway\nWashington\nDC\n\n1\n0\n\n\n1\n390551098-7\n2\nHousehold\nHelga Benech\nHelga\nBenech\n\n\n\n\nebenech1@goodreads.com\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n0\n0\n\n\n2\n093004505-X\n3\nHousehold\nMasha Butt Gow\nMasha\nButt Gow\n\n\n\n818-323-9865\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n0\n0\n\n\n3\n729707142-0\n4\nOrganization\nCymbre Cross\nCymbre\nCross\n\n\n\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n\n0\n0\n\n\n4\n488464926-5\n5\nHousehold\nHoyt Castille\nHoyt\nCastille\n\n\n\n\nfcastille4@timesonline.co.uk\n37 8th Trail\nGrand Rapids\nMI\n49560\n0\n0"
  },
  {
    "objectID": "01_SQL_Solution.html#gifts",
    "href": "01_SQL_Solution.html#gifts",
    "title": "SQL Solution",
    "section": "Gifts",
    "text": "Gifts\n\nCreating the final gifts column \n\n\nThe cleaning is done \nCreating the gifts table and renaming some columns \n\n\nproc = \"\"\"\nCREATE TABLE IF NOT EXISTS gifts (\n    LegacyContactId VARCHAR(255),\n    LegacyGiftId INTEGER,\n    GiftType TEXT,\n    GiftDate TEXT,\n    GiftAmount REAL,\n    Notes TEXT,\n    CreditCardType TEXT,\n    Project1Code TEXT,\n    Project2Code TEXT,\n    LegacyPledgeID INTEGER\n);\n\ninsert into gifts\nselect \n    DonorNumber as LegacyContactId,\n    LegacyGiftId,\n    PaymentMethod as GiftType,\n    GiftDate,\n    AmountReceived as GiftAmount,\n    Notes,\n    CreditCardType,\n    Project1Code,\n    Project2Code,\n    LegacyPledgeID\nfrom temp_gifts;\n\ncommit;\n\"\"\"\ninsert_proc(proc, 'create_gifts', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\n\n\n\n\npd.read_sql('select * from gifts limit 5', engine)\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyGiftId\nGiftType\nGiftDate\nGiftAmount\nNotes\nCreditCardType\nProject1Code\nProject2Code\nLegacyPledgeID\n\n\n\n\n0\n848348568-0\n95196378\nOther\n2019-03-04 00:00:00\n4.1500\n\n\n\nNone\n0\n\n\n1\n729707142-0\n95196889\nCheck\n2019-03-05 00:00:00\n2.3648\n\n\nChildSponsorship\nNone\n1\n\n\n2\n687119652-8\n95197689\nCash\n2019-03-07 00:00:00\n1.3100\n\n\n\nNone\n2\n\n\n3\n653377813-7\n95198998\nCredit\n2019-03-10 00:00:00\n2.0400\nIn honor of Mannie Turpin\nAMEX\n\nNone\n3\n\n\n4\n390551098-7\n95198999\nCash\n2019-01-10 00:00:00\n5.8000\n\n\n\nNone\n89752384"
  },
  {
    "objectID": "01_SQL_Solution.html#contact-methods",
    "href": "01_SQL_Solution.html#contact-methods",
    "title": "SQL Solution",
    "section": "Contact Methods",
    "text": "Contact Methods\n\n &gt; Procedure to create contact_methods table  \n\nCreating a contact_methods \nInserting distinct values from the contacts table \n\n\npd.read_sql(\"\"\"\n    SELECT DISTINCT\n        contacts.`LegacyContactId` AS LegacyContactId,\n        contacts.`HomePhone` AS HomePhone,\n        contacts.`HomeEmail` AS HomeEmail,\n        temp_contact_methods.Fax AS fax\n    FROM \n        contacts\n    JOIN\n        temp_contact_methods ON temp_contact_methods.DonorNumber = contacts.`LegacyContactId`;\n            \"\"\", engine)\n\n\n\n\n\n\n\n\nLegacyContactId\nHomePhone\nHomeEmail\nfax\n\n\n\n\n0\n653377813-7\n832-442-4988\nkklumbers@yahoo.com\n\n\n\n1\n390551098-7\n\nebenech1@goodreads.com\n\n\n\n2\n093004505-X\n818-323-9865\n\n818-156-7985\n\n\n3\n729707142-0\n\n\n\n\n\n4\n488464926-5\n\nfcastille4@timesonline.co.uk\n\n\n\n5\n315297729-8\n\ndmouncey9@cnn.com\n\n\n\n6\n315297729-8\n\n\n\n\n\n7\n848348568-0\n702-844-9524\n\n\n\n\n8\n029456846-8\n\njdoley6@telegraph.co.uk\n\n\n\n9\n687119652-8\n\ncmakepeace7@1688.com\n\n\n\n10\n739131380-7\n\n\n626-981-3874\n\n\n\n\n\n\n\n\n\nproc = \"\"\"\nCREATE TABLE IF NOT EXISTS contact_methods (\n    `LegacyContactId` VARCHAR(255),\n    `Type` VARCHAR(255),\n    `Value` VARCHAR(255)\n);\n\nBEGIN\nDECLARE done INT DEFAULT FALSE;\nDECLARE v_LegacyContactId VARCHAR(255);\nDECLARE v_HomePhone VARCHAR(255);\nDECLARE v_HomeEmail VARCHAR(255);\nDECLARE v_Fax VARCHAR(255);\nDECLARE cur CURSOR FOR \n    SELECT DISTINCT\n        contacts.`LegacyContactId` AS LegacyContactId,\n        contacts.`HomePhone` AS HomePhone,\n        contacts.`HomeEmail` AS HomeEmail,\n        temp_contact_methods.Fax AS fax\n    FROM \n        contacts\n    JOIN\n        temp_contact_methods ON temp_contact_methods.DonorNumber = contacts.`LegacyContactId`;\n\nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;\n\n    OPEN cur;\n\n    read_loop: LOOP\n        FETCH cur INTO v_LegacyContactId, v_HomePhone, v_HomeEmail,v_Fax;\n        \n        IF done THEN\n            LEAVE read_loop;\n        END IF;\n\n        INSERT INTO contact_methods (`LegacyContactId`, `Type`, `Value`) VALUES \n            (v_LegacyContactId, 'HomePhone', v_HomePhone),\n            (v_LegacyContactId, 'HomeEmail', v_HomeEmail),\n            (v_LegacyContactId, 'Fax', v_Fax);\n    END LOOP;\n\n    CLOSE cur;\nEND;\n\n-- Delete records from contact methods where value is null or ''\nDELETE FROM contact_methods WHERE `Value` IS NULL OR `Value` = '';\n\n\ncommit;\n\n\n\"\"\"\ninsert_proc(proc, 'transform_contact_methods', call=True)\n\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\nSQL executed successfully\nMySQL connection closed\n\n\n\n\npd.read_sql('select * from contact_methods order by LegacyContactId', con=engine)\n\n\n\n\n\n\n\n\nLegacyContactId\nType\nValue\n\n\n\n\n0\n029456846-8\nHomeEmail\njdoley6@telegraph.co.uk\n\n\n1\n093004505-X\nHomePhone\n818-323-9865\n\n\n2\n093004505-X\nFax\n818-156-7985\n\n\n3\n315297729-8\nHomeEmail\ndmouncey9@cnn.com\n\n\n4\n390551098-7\nHomeEmail\nebenech1@goodreads.com\n\n\n5\n488464926-5\nHomeEmail\nfcastille4@timesonline.co.uk\n\n\n6\n653377813-7\nHomePhone\n832-442-4988\n\n\n7\n653377813-7\nHomeEmail\nkklumbers@yahoo.com\n\n\n8\n687119652-8\nHomeEmail\ncmakepeace7@1688.com\n\n\n9\n739131380-7\nFax\n626-981-3874\n\n\n10\n848348568-0\nHomePhone\n702-844-9524"
  },
  {
    "objectID": "00_Setup.html",
    "href": "00_Setup.html",
    "title": "Setup",
    "section": "",
    "text": "Loading Datasets using Pandas\n\n\ncontacts.head()\n\n\n\n\n\n\n\n\nNumber\nCompany Name\nFirst Name\nLast Name\nStreet\nCity\nState\nPostal\nPhone\nE-mail\nRemarks\nDeceased?\n\n\n\n\n0\n653377813-7\n\nKarita & Kelvin\nLumbers\n4 Bunting Parkway\nWashington\nDC\n20535-871\nkklumbers@ yahoo.co\n\nIs anonymous\n\n\n\n1\n390551098-7\n\nHelga\nBenech\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n\nebenech1@goodreads.com\n\n\n\n\n2\n093004505-X\n\nMasha\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n\n577-374-96523\n\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n8104\n\n\n\nNo\n\n\n4\n488464926-5\n\nHoyt\nCastille\n37 8th Trail\nGrand Rapids\nMI\n49560\n\nfcastille4@timesonline.co.uk\n\nNo\n\n\n\n\n\n\n\n\ngifts.head()\n\n\n\n\n\n\n\n\ndonor_number\ngift_id\nfirst_name\nlast_name\namount received\ndate\nfund_id\ncredit card type\npayment method\npledge_number\nnotes\n\n\n\n\n0\n848348568-0\n95196378.0\nMannie\nTurpin\n$4.15\n3/4/2019\n\n\nPayPal\n\n\n\n\n1\n729707142-0\n95196889.0\nCymbre\nCross\n2.3648\n3/5/2019\nChildSponsorship\n\ncheck\n\n\n\n\n2\n687119652-8\n95197689.0\nRuggiero\nMakepeace\n$1.31\n3/7/2019\n\n\ncash\n\n\n\n\n3\n653377813-7\n95198998.0\nKarita\nLumbers\n$2.04\n3/10/2019\n\nAmerican Ex\ncredit card\n\nIn honor of Mannie Turpin\n\n\n4\n390551098-7\n95198999.0\nHelga\nBenech\n$5.80\n2019/1/10\n\n\ncash\n89752384.0\n\n\n\n\n\n\n\n\n\ncontact_methods.head()\n\n\n\n\n\n\n\n\ndonor_number\nPhone\nE-mail\nFax\n\n\n\n\n0\n653377813-7\n832-442-4988\n\n\n\n\n1\n390551098-7\n\nebenech1@goodreads.com\n\n\n\n2\n093004505-X\n818-323-9865\n\n818-156-7985\n\n\n3\n729707142-0\n\n\n\n\n\n4\n488464926-5\n\nfcastille4@timesonline.co.uk"
  },
  {
    "objectID": "00_Setup.html#column-name-transformation",
    "href": "00_Setup.html#column-name-transformation",
    "title": "Setup",
    "section": "Column Name Transformation",
    "text": "Column Name Transformation\n\n\nNothing worse than malformed column names, amiright?  \n\n\nCreating a Func to Convert String to CamelCase\n\ndef to_camel_case(s):\n    # Remove all non-alphanumeric characters and replace with a space\n    s = re.sub(r'[^a-zA-Z0-9]', ' ', s)\n    \n    # Split by space and capitalize the first letter of each word\n    words = s.split()\n    return ''.join(word.capitalize() for word in words)\n\n\nsource\n\n\nto_camel_case\n\n to_camel_case (s)\n\nstripping spaces\n\nto_camel_case('this isa test')\n\n'ThisIsaTest'\n\n\nStripping Special Characters\n\nto_camel_case('this_is_a_test')\n\n'ThisIsATest'\n\n\n\nto_camel_case('hello!world_what_is_up?')\n\n'HelloWorldWhatIsUp'\n\n\n\n\nCreating seperate function to apply string transformation to pandas columns \n It may not always be the case that I want to apply to_camel_case as the column transformation   Because of this I’m going to set the apply func to be a optional parameter\n\ndef transform_cnames(df, func=to_camel_case):\n    df.columns = df.columns.map(func)\n    return None\n\n\nsource\n\n\ntransform_cnames\n\n transform_cnames (df, func=&lt;function to_camel_case&gt;)\n\n\n\nApplying Transformation \nGoing to transform the column names of each of the 3 tables\n\nfor df in [contact_methods, contacts, gifts]:\n    transform_cnames(df)\n\nValidating that the contacts column names are now CamelCase\n\ncontacts.columns\n\nIndex(['Number', 'CompanyName', 'FirstName', 'LastName', 'Street', 'City',\n       'State', 'Postal', 'Phone', 'EMail', 'Remarks', 'Deceased'],\n      dtype='object')"
  },
  {
    "objectID": "00_Setup.html#column-type-transformation",
    "href": "00_Setup.html#column-type-transformation",
    "title": "Setup",
    "section": "Column Type Transformation",
    "text": "Column Type Transformation\n\nI identified 2 columns on the gift table that should be ints \nI’m going to convert them both to type int\n\nint_cols = ['GiftId', 'PledgeNumber']\n\n\ngifts[int_cols] = gifts[int_cols].replace({'':0}).astype(int)\n\nAmountRecieved should be a float,= \nI’m remove any special characters (besides dashes and periods) and converting to a float :)\n\ngifts['AmountReceived'] = gifts.AmountReceived.apply(lambda x: float(re.sub(r'[^a-zA-Z0-9\\.-]', '', x)))\n\nPreviewing change\n\ngifts.AmountReceived.head(5)\n\n0    4.1500\n1    2.3648\n2    1.3100\n3    2.0400\n4    5.8000\nName: AmountReceived, dtype: float64\n\n\nI previously replaced na values with 0 \nI’m now going to replace ‘0’ values in PledgeNumber & GiftId to thier index so that each row is unique\n\ngifts.loc[ gifts.PledgeNumber == 0, 'PledgeNumber'] = gifts[gifts.PledgeNumber == 0].index\ngifts.loc[ gifts.GiftId == 0, 'GiftId'] = gifts[gifts.GiftId == 0].index\n\nRenaming the columns to match virtuous requirements\n\ngifts = gifts.rename(columns={'PledgeNumber': 'LegacyPledgeID', 'GiftId': 'LegacyGiftId'})"
  },
  {
    "objectID": "00_Setup.html#misplaced-data-transformation",
    "href": "00_Setup.html#misplaced-data-transformation",
    "title": "Setup",
    "section": "Misplaced Data Transformation",
    "text": "Misplaced Data Transformation\n\nIdentify and clean any pieces of data in the wrong column\n\n\ncontacts[['Phone', 'EMail']].head(3)\n\n\n\n\n\n\n\n\nPhone\nEMail\n\n\n\n\n0\nkklumbers@ yahoo.co\n\n\n\n1\n\nebenech1@goodreads.com\n\n\n2\n\n577-374-96523\n\n\n\n\n\n\n\nCreating a function that uses regular expressions to identify a string as a phone or a email\n\ndef classify_phone_email(value):\n    if \"@\" in value:\n        return \"email\"\n    if re.search(r'\\d{3}-\\d{3}-\\d{4}', value):\n        return \"phone\"\n    return None\n\n\nsource\n\nclassify_phone_email\n\n classify_phone_email (value)\n\n\nclassify_phone_email('321-295-2502')\n\n'phone'\n\n\n\nclassify_phone_email('warren.hyson5@gmail.com')\n\n'email'\n\n\n\nclassify_phone_email('test321-29@gmail.com')\n\n'email'\n\n\n\nclassify_phone_email('3212952502@gmail.com')\n\n'email'\n\n\n\nclassify_phone_email('321-295-2502@gmail.com')\n\n'email'\n\n\n\n\nApplying Phone/Email Transformation\nLooping over phone & email records.  If a phone and/or email are identified in the wrong column, they will be swapped\n\nfor index, row in contacts.iterrows():\n    phone_classification = classify_phone_email(row['Phone'])\n    email_classification = classify_phone_email(row['EMail'])\n\n    if phone_classification == \"email\":\n        contacts.at[index, 'EMail'] = row['Phone']\n        contacts.at[index, 'Phone'] = ''\n\n    if email_classification == \"phone\":\n        contacts.at[index, 'Phone'] = row['EMail']\n        contacts.at[index, 'EMail'] = ''\n\n\ncontacts[['Phone', 'EMail']].head(3)\n\n\n\n\n\n\n\n\nPhone\nEMail\n\n\n\n\n0\n\nkklumbers@ yahoo.co\n\n\n1\n\nebenech1@goodreads.com\n\n\n2\n577-374-96523"
  },
  {
    "objectID": "00_Setup.html#consolidate-contacts-table",
    "href": "00_Setup.html#consolidate-contacts-table",
    "title": "Setup",
    "section": "Consolidate Contacts Table",
    "text": "Consolidate Contacts Table\n\nSearching for missing users \nSplitting / joining households \n\n\nChecking for Missing records\nChecking for any DonorNumbers that are NOT IN contacts Number…\n\n(~gifts.DonorNumber.isin(contacts.Number.unique())).any()\n\nTrue\n\n\nFound 1!   Doing the same for contact_methods\n\n(~contact_methods.DonorNumber.isin(contacts.Number.unique())).any()\n\nFalse\n\n\nDidn’t find any there  Going to extract the missing records from the gifts table\n\ndonors_not_in_contacts = gifts.loc[~gifts.DonorNumber.isin(contacts.Number.unique()), :]\n\n\ndonors_not_in_contacts\n\n\n\n\n\n\n\n\nDonorNumber\nLegacyGiftId\nFirstName\nLastName\nAmountReceived\nDate\nFundId\nCreditCardType\nPaymentMethod\nLegacyPledgeID\nNotes\n\n\n\n\n9\n809975531-Y\n9\nAdeline\nShakespeare\n8.48\n8/14/2019\n\nAMEX\ncredit card\n9\n\n\n\n27\n809975531-Y\n27\nAdeline\nShakespeare\n7.58\n8/14/2019\nColor run, ChildSponsorship\nMastercard\ncredit card\n27\n\n\n\n\n\n\n\n\nAdding to Shakespeare to our contacts!\n\ncontacts = pd.concat([\n    contacts,\n    # Dataframe of donors not in contacts\n    pd.DataFrame(donors_not_in_contacts[['DonorNumber', 'FirstName', 'LastName']]\n                 .drop_duplicates()\n                 .rename(columns={'DonorNumber': 'Number'})\n                 .drop_duplicates()\n                 .to_dict('records'))\n])\n\n\n\nSpliting rows with Multiple People\n\ncontacts.FirstName.head(1)\n\n0    Karita & Kelvin\nName: FirstName, dtype: object\n\n\nSplit the names on ’ & ’ or ’ and ’, then expand the resulting lists into new rows\n\ncontacts[['FirstName', 'SecondaryFirstName']] = contacts['FirstName'].str.split(' & | and ', expand=True).fillna('')\n\nAditionally, going to look for any records where there’s a duplicated Number  \nThe following Python code will return True for rows where the Number was deemed to be a duplicate:\ncontacts.Number.duplicated()\nFor all the rows that are duplicates, I’m going to: 1. Place them in a seperate variable  2. Remove them from the original dataset  3. Add them as the 2nd Person on the non-duplicated row  4. Ensure they have proper first & last names\n\nrecords_to_join = contacts.loc[contacts.Number.duplicated(), :].to_dict(orient='records')\n\nRemoving duplicates from contacts before joining\n\ncontacts = contacts.loc[~contacts.Number.duplicated(), :]\n\nAdding dupliates as secondary contacts\n\nfor record in records_to_join:\n    contacts.loc[contacts.Number.isin([record['Number']]), ['SecondaryFirstName', 'SecondaryLastName']] = [record['FirstName'], record['LastName']]\n\nAdding Secondary Last Name where it was previously missing\n\ncontacts['SecondaryLastName'] = contacts.apply(lambda x: x['LastName'] if x['SecondaryLastName'] == '' and x['SecondaryFirstName'] != '' else x['SecondaryLastName'], axis=1)\n\n\n\nUpdating unique identifiers\n\nEnsuring LegacyIndividualId is present for all contacts & is unique\n\nInitalizing empty collumns\nAdding id since none was provided\n\nid = 0\nfor index, row in contacts.iterrows():\n    contacts.loc[index, 'LegacyIndividualId'] = id\n    id += 1\n    if row['SecondaryFirstName'] != '':\n        contacts.loc[index, 'SecondaryLegacyIndividualId'] = id\n        id += 1"
  },
  {
    "objectID": "00_Setup.html#cleaning-contact-names",
    "href": "00_Setup.html#cleaning-contact-names",
    "title": "Setup",
    "section": "Cleaning Contact Names",
    "text": "Cleaning Contact Names\n\nCleaning Records with blank first or last names \n\nChecking for records where FirstName and/or LastName is blank\n\nblank_name_records = ((contacts.FirstName == '') | (contacts.LastName == ''))\n\nPreviewing the blank name records\n\ncontacts.loc[((contacts.FirstName == '') | (contacts.LastName == '')), :]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\n\n\n\n\n2\n093004505-X\n\nMasha\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n577-374-96523\n\n\n\n\n\n3\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n8104\n\n\n\nNo\n\n\n4\n\n\n\n7\n029456846-8\n\n\n\n608 Old Shore Alley\nMarietta\nGA\n30066\n\njdoley6@telegraph.co.uk\n\n\n\n\n9\n\n\n\n\n\n\n\n\nBefore I delete the records I’m going to check if the names are present on the gift table   I’m going to start by getting the unique Numbers that the records belong too\n\nblank_name_numbers= contacts.loc[blank_name_records, 'Number']\n\n\ngifts.loc[gifts.DonorNumber.isin(blank_name_numbers), ['DonorNumber', 'FirstName', 'LastName']].drop_duplicates().head(5)\n\n\n\n\n\n\n\n\nDonorNumber\nFirstName\nLastName\n\n\n\n\n1\n729707142-0\nCymbre\nCross\n\n\n6\n029456846-8\nRomy\nDoley\n\n\n7\n093004505-X\nMasha\nButt Gow\n\n\n19\n729707142-0\nCymbre\n\n\n\n\n\n\n\n\nThe names are present on the gifts table!\n\ngift_name_records = gifts.loc[gifts.DonorNumber.isin(blank_name_numbers), ['DonorNumber', 'FirstName', 'LastName']].drop_duplicates()\n\nRemoving the invalid record\n\ngift_name_records = gift_name_records.loc[((gift_name_records.FirstName != '') & (gift_name_records.LastName != '')), :]\ngift_name_records\n\n\n\n\n\n\n\n\nDonorNumber\nFirstName\nLastName\n\n\n\n\n1\n729707142-0\nCymbre\nCross\n\n\n6\n029456846-8\nRomy\nDoley\n\n\n7\n093004505-X\nMasha\nButt Gow\n\n\n\n\n\n\n\nUpdating the records that previousuly had a blank first or last name\n\nfor _, row in gift_name_records.iterrows():\n    contacts.loc[contacts['Number'] == row['DonorNumber'], ['FirstName', 'LastName']] = [row['FirstName'], row['LastName']]\n\nAll the records valid names now!\n\ncontacts.loc[blank_name_records, :]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\n\n\n\n\n2\n093004505-X\n\nMasha\nButt Gow\n353 Schmedeman Park\nIndianapolis\nIN\n\n577-374-96523\n\n\n\n\n\n3\n\n\n\n3\n729707142-0\nA Company Co.\nCymbre\nCross\n2055 Lakewood Parkway\nCamden\nNJ\n8104\n\n\n\nNo\n\n\n4\n\n\n\n7\n029456846-8\n\nRomy\nDoley\n608 Old Shore Alley\nMarietta\nGA\n30066\n\njdoley6@telegraph.co.uk\n\n\n\n\n9"
  },
  {
    "objectID": "00_Setup.html#add-contact-name",
    "href": "00_Setup.html#add-contact-name",
    "title": "Setup",
    "section": "Add Contact Name",
    "text": "Add Contact Name\n\nAdding Contact Name\n\n\ncontacts.head(3)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\n\n\n\n\n0\n653377813-7\n\nKarita\nLumbers\n4 Bunting Parkway\nWashington\nDC\n20535-871\n\nkklumbers@ yahoo.co\nIs anonymous\n\nKelvin\nLumbers\n0\n1\n\n\n1\n390551098-7\n\nHelga\nBenech\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n\nebenech1@goodreads.com\n\n\n\n\n2\n\n\n\n2\n093004505-X\n\nMasha\nButt Gow\n353 Schmedeman Park\nIndianapolis\nIN\n\n577-374-96523\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\nCreating a function to update the contact name depending on the individuals on the household record\n\ndef set_contact_name(row):\n    if row['LastName'] == row['SecondaryLastName']:\n        return row['FirstName'] + ' & ' + row['SecondaryFirstName'] + ' ' + row['LastName']\n    elif row['SecondaryFirstName'] != '':\n        return row['FirstName'] +  ' ' + row['LastName'] + ' & ' + row['SecondaryFirstName'] + ' ' + row['SecondaryLastName']\n    else:\n        return row['FirstName'] + ' ' + row['LastName']\n\n\nsource\n\nset_contact_name\n\n set_contact_name (row)\n\n\n\nApplying ContactName Transformation\n\ncontacts['ContactName'] = contacts.apply(set_contact_name, axis=1)\n\nPreviewing result\n\ncontacts[['ContactName', 'FirstName', 'LastName', 'SecondaryFirstName', 'SecondaryLastName']].head(5)\n\n\n\n\n\n\n\n\nContactName\nFirstName\nLastName\nSecondaryFirstName\nSecondaryLastName\n\n\n\n\n0\nKarita & Kelvin Lumbers\nKarita\nLumbers\nKelvin\nLumbers\n\n\n1\nHelga Benech\nHelga\nBenech\n\n\n\n\n2\nMasha Butt Gow\nMasha\nButt Gow\n\n\n\n\n3\nCymbre Cross\nCymbre\nCross\n\n\n\n\n4\nHoyt Castille\nHoyt\nCastille"
  },
  {
    "objectID": "00_Setup.html#projectcode-transformation",
    "href": "00_Setup.html#projectcode-transformation",
    "title": "Setup",
    "section": "ProjectCode Transformation",
    "text": "ProjectCode Transformation\n\nSplitting Project Codes\n\nSplitting the FundId column by ','\n\nproject_codes = gifts.FundId.str.split(', ', expand=True)\n\n\nproject_codes.head(6)\n\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n0\n\nNone\n\n\n1\nChildSponsorship\nNone\n\n\n2\n\nNone\n\n\n3\n\nNone\n\n\n4\n\nNone\n\n\n5\nGeneral\nReliefFund\n\n\n\n\n\n\n\n\n\nAssigning the values to the Project1 & 2 columns\n\ngifts[['Project1Code', 'Project2Code']] = project_codes\n\nRemoving FundId from the dataset\n\ngifts = gifts.loc[:, gifts.columns.drop('FundId')].copy()"
  },
  {
    "objectID": "00_Setup.html#date-transformation",
    "href": "00_Setup.html#date-transformation",
    "title": "Setup",
    "section": "Date Transformation",
    "text": "Date Transformation\n\nFormating date\n\n\ndf['Date'].head(5)\n\n0     3/4/2019\n1     3/5/2019\n2     3/7/2019\n3    3/10/2019\n4    2019/1/10\nName: Date, dtype: object\n\n\nSince Dates are in different formats I’m going to create a custom parser\n\ndef custom_parser(date_str):\n    try:\n        return datetime.strptime(date_str, '%m/%d/%Y')\n    except ValueError:\n        return datetime.strptime(date_str, '%Y/%m/%d')\n\n\nsource\n\ncustom_parser\n\n custom_parser (date_str)\n\n\n\nExamples\n\ncustom_parser('4/14/1999')\n\ndatetime.datetime(1999, 4, 14, 0, 0)\n\n\n\ncustom_parser('1999/04/14')\n\ndatetime.datetime(1999, 4, 14, 0, 0)\n\n\n\n\nTransforming Dates\n\ngifts['GiftDate'] = gifts['Date'].apply(custom_parser)\n\nDropping old date columns\n\ngifts = gifts.loc[:, gifts.columns.drop('Date')].copy()"
  },
  {
    "objectID": "00_Setup.html#email-transformation",
    "href": "00_Setup.html#email-transformation",
    "title": "Setup",
    "section": "Email Transformation",
    "text": "Email Transformation\n\nValidate emails\n\nPreviewing the Email column\n\ncontacts.EMail.head(1)\n\n0    kklumbers@ yahoo.co\nName: EMail, dtype: object\n\n\nIt looks like the first email ‘kklumbers@ yahoo.co’ is invalid and should be fixed   I’m going to write a function to validate emails and fix common mistakes\n\ndef valid_email(s):\n    pattern = re.compile(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$')\n    if pattern.match(s):\n        return True\n    return False\n\n\nsource\n\nvalid_email\n\n valid_email (s)\n\n\nvalid_email('warren.hyson5@gmail.com')\n\nTrue\n\n\n\nvalid_email('warren.hyson5@gmail')\n\nFalse\n\n\n\nvalid_email('warren.hyson5@.com')\n\nFalse\n\n\n\nvalid_email('warren.hyson5@gmailcom')\n\nFalse\n\n\n\nvalid_email('warren.hyson5@@gmail.com')\n\nFalse\n\n\n Creating a second function that attempts to fix common email mistakes like mispelled domains\n\ndef fix_email(email):\n    if not email:\n        return ''\n    \n    email = re.sub(r'\\s', '', email)\n\n    # Check and fix common mistakes in top-level domain (TLD)\n    for wrong_tld, correct_tld in [('co', 'com'), ('cmo', 'com'), ('con', 'com')]:\n        if email.endswith('.' + wrong_tld):\n            email = email[:-len(wrong_tld)] + correct_tld\n\n    # Check and fix common mistakes in domain names\n    for wrong_domain, correct_domain in [('gmial', 'gmail'), ('yahho', 'yahoo')]:\n        email = email.replace('@' + wrong_domain, '@' + correct_domain)\n\n    if valid_email(email):\n        return email\n\n    return ''\n\n\nsource\n\n\nfix_email\n\n fix_email (email)\n\ncorrect\n\nfix_email('warren.hyson5@gmail.com')\n\n'warren.hyson5@gmail.com'\n\n\ngmail spelled wrong\n\nfix_email('warren.hyson5@gmial.com')\n\n'warren.hyson5@gmail.com'\n\n\ncom spelled wrong\n\nfix_email('warren.hyson5@gmial.con')\n\n'warren.hyson5@gmail.com'\n\n\n\n\nApplying Email Transformation\nPreviewing\n\ncontacts.EMail.head(1).apply(fix_email)\n\n0    kklumbers@yahoo.com\nName: EMail, dtype: object\n\n\n\ncontacts['EMail'] = contacts.EMail.apply(fix_email)"
  },
  {
    "objectID": "00_Setup.html#phone-transformation",
    "href": "00_Setup.html#phone-transformation",
    "title": "Setup",
    "section": "Phone # Transformation",
    "text": "Phone # Transformation\n\nFix phone numbers\n\nThere appears to be a invalid phone number\n\ncontacts.loc[2, 'Phone']\n\n'577-374-96523'\n\n\nWriting a function to validate US phone numbers, assuming the phone numbers provided are from the US\n\ndef validate_us_phone_number(phone_number):\n    # Patterns for different US phone number formats\n    patterns = [\n        r'^\\+1\\s?\\d{3}-\\d{3}-\\d{4}$',\n        r'^\\(\\d{3}\\)\\s?\\d{3}-\\d{4}$',\n        r'^\\d{3}-\\d{3}-\\d{4}$',\n        r'^\\d{3}-\\d{4}$' \n    ]\n\n    # Check if the phone number matches any of the patterns\n    for pattern in patterns:\n        if re.match(pattern, phone_number):\n            return phone_number\n\n    # Checking if the string contains only numbers and is of length 7 or 10\n    numeric_string = re.sub('[^0-9]', '', phone_number)\n    length = len(numeric_string)\n    if length == 7 or length == 10:\n        return phone_number\n\n    return ''\n\n\nsource\n\nvalidate_us_phone_number\n\n validate_us_phone_number (phone_number)\n\n\nvalidate_us_phone_number('321-295-2502')\n\n'321-295-2502'\n\n\nno-dashes 10 digit\n\nvalidate_us_phone_number('3212952502')\n\n'3212952502'\n\n\nno-dashes 7 digit\n\nvalidate_us_phone_number('2952502')\n\n'2952502'\n\n\nno-dashes 11\n\nvalidate_us_phone_number('13212952502')\n\n''\n\n\n\nvalidate_us_phone_number(\"(123) 456-7890\")\n\n'(123) 456-7890'\n\n\nRandom Text\n\nvalidate_us_phone_number('407-555-1234 ext. 1234')\n\n''\n\n\n\n\nApplying Phone # Transformation\n\ncontacts['Phone'] = contacts.Phone.apply(validate_us_phone_number)\n\n\ncontacts.fillna('', inplace=True)"
  },
  {
    "objectID": "04_Test.html",
    "href": "04_Test.html",
    "title": "Validation",
    "section": "",
    "text": "import pandas as pd\nimport re\nfrom virtuous_interview.utils import valid_email, validate_us_phone_number\nfrom virtuous_interview.solution_pd import postal_code_pattern\nfrom nbdev.showdoc import *\nfinal_contacts = pd.read_csv('data/final_contacts.csv').fillna('')\nfinal_contact_methods = pd.read_csv('data/final_contact_methods.csv').fillna('')\nfinal_gifts = pd.read_csv('data/final_gifts.csv').fillna('')"
  },
  {
    "objectID": "04_Test.html#validating-required-fields-are-not-missing",
    "href": "04_Test.html#validating-required-fields-are-not-missing",
    "title": "Validation",
    "section": "Validating Required Fields Are Not Missing",
    "text": "Validating Required Fields Are Not Missing\n\ndef test_contact_required_fields():\n    missing_no_required_fields(final_contacts, ['LegacyContactId', 'LegacyIndividualId', 'ContactType', 'FirstName', 'LastName'])\n\n\nsource\n\ntest_contact_required_fields\n\n test_contact_required_fields ()\n\n\n\ntest_contact_required_fields()"
  },
  {
    "objectID": "04_Test.html#validating-contacttype",
    "href": "04_Test.html#validating-contacttype",
    "title": "Validation",
    "section": "Validating ContactType",
    "text": "Validating ContactType\n\ndef test_contacts_contact_type():\n    assert final_contacts.ContactType.isin(['Household', 'Organization']).all()\n\n\nsource\n\ntest_contacts_contact_type\n\n test_contacts_contact_type ()\n\n\n\ntest_contacts_contact_type()"
  },
  {
    "objectID": "04_Test.html#validating-email",
    "href": "04_Test.html#validating-email",
    "title": "Validation",
    "section": "Validating Email",
    "text": "Validating Email\n\ndef test_contact_email():\n    assert final_contacts.HomeEmail.apply(email_is_valid).all()\n\n\nsource\n\ntest_contact_email\n\n test_contact_email ()\n\n\n\ntest_contact_email()"
  },
  {
    "objectID": "04_Test.html#validating-phone-number",
    "href": "04_Test.html#validating-phone-number",
    "title": "Validation",
    "section": "Validating Phone Number",
    "text": "Validating Phone Number\n\ndef test_contact_phone_number_valid():\n    assert final_contacts.HomePhone.apply(number_is_valid).all()\n\n\nsource\n\ntest_contact_phone_number_valid\n\n test_contact_phone_number_valid ()\n\n\n\ntest_contact_phone_number_valid()"
  },
  {
    "objectID": "04_Test.html#validating-postal",
    "href": "04_Test.html#validating-postal",
    "title": "Validation",
    "section": "Validating Postal",
    "text": "Validating Postal\n\ndef test_contact_valid_zip():\n    assert final_contacts.PostalCode.apply(zip_is_valid).all()\n\n\nsource\n\ntest_contact_valid_zip\n\n test_contact_valid_zip ()\n\n\n\ntest_contact_valid_zip()"
  },
  {
    "objectID": "04_Test.html#validating-deceased",
    "href": "04_Test.html#validating-deceased",
    "title": "Validation",
    "section": "Validating Deceased",
    "text": "Validating Deceased\n\ndef test_contact_deceased():\n    assert final_contacts.IsDeceased.isin([True, False]).all()\n\n\n\ntest_contact_deceased()"
  },
  {
    "objectID": "04_Test.html#validating-required-fields-are-not-missing-1",
    "href": "04_Test.html#validating-required-fields-are-not-missing-1",
    "title": "Validation",
    "section": "Validating Required Fields Are Not Missing",
    "text": "Validating Required Fields Are Not Missing\n\ndef test_gift_required_fields():\n    missing_no_required_fields(final_gifts, ['LegacyContactId', 'LegacyGiftId', 'GiftType', 'GiftDate', 'GiftAmount', 'LegacyPledgeID'])\n\n\nsource\n\ntest_gift_required_fields\n\n test_gift_required_fields ()\n\n\n\ntest_gift_required_fields()"
  },
  {
    "objectID": "04_Test.html#validating-gifttype",
    "href": "04_Test.html#validating-gifttype",
    "title": "Validation",
    "section": "Validating GiftType",
    "text": "Validating GiftType\n\ndef test_gift_type():\n    assert final_gifts.GiftType.isin(['Cash', 'Check', 'Credit', 'Other',  'Reversing Transaction']).all()\n\n\nsource\n\ntest_gift_type\n\n test_gift_type ()\n\n\n\ntest_gift_type()"
  },
  {
    "objectID": "04_Test.html#validating-giftamount",
    "href": "04_Test.html#validating-giftamount",
    "title": "Validation",
    "section": "Validating GiftAmount",
    "text": "Validating GiftAmount\n\n# Assert final_gifts['GiftAmount'] is a float\ndef test_gift_amount_is_float():\n    assert final_gifts['GiftAmount'].dtype == 'float64'\n\n\nsource\n\ntest_gift_amount_is_float\n\n test_gift_amount_is_float ()\n\n\n\ntest_gift_amount_is_float()"
  },
  {
    "objectID": "04_Test.html#validating-creditcardtype",
    "href": "04_Test.html#validating-creditcardtype",
    "title": "Validation",
    "section": "Validating CreditCardType",
    "text": "Validating CreditCardType\n\ndef test_credit_card_type():\n    assert final_gifts.CreditCardType.isin(['Visa', 'Mastercard', 'AMEX', 'Discover', '']).all()\n\n\nsource\n\ntest_credit_card_type\n\n test_credit_card_type ()\n\n\n\ntest_credit_card_type()"
  },
  {
    "objectID": "04_Test.html#validating-pledgeid",
    "href": "04_Test.html#validating-pledgeid",
    "title": "Validation",
    "section": "Validating PledgeId",
    "text": "Validating PledgeId\n\ndef test_gift_pledge_id():\n    assert len(final_gifts) == len(final_gifts.LegacyPledgeID.unique())\n\n\nsource\n\ntest_gift_pledge_id\n\n test_gift_pledge_id ()\n\n\n\ntest_gift_pledge_id()"
  },
  {
    "objectID": "04_Test.html#validating-required-fields-are-not-missing-2",
    "href": "04_Test.html#validating-required-fields-are-not-missing-2",
    "title": "Validation",
    "section": "Validating Required Fields Are Not Missing",
    "text": "Validating Required Fields Are Not Missing\n\ndef test_contact_method_required_fields():\n    missing_no_required_fields(final_contact_methods, ['LegacyContactId', 'Type', 'Value'])\n\n\nsource\n\ntest_contact_method_required_fields\n\n test_contact_method_required_fields ()\n\n\n\ntest_contact_method_required_fields()"
  },
  {
    "objectID": "04_Test.html#validating-type",
    "href": "04_Test.html#validating-type",
    "title": "Validation",
    "section": "Validating Type",
    "text": "Validating Type\n\ndef test_contact_method_type():\n    assert final_contact_methods.Type.isin(['HomePhone', 'HomeEmail', 'Fax']).all()\n\n\nsource\n\ntest_contact_method_type\n\n test_contact_method_type ()\n\n\n\ntest_contact_method_type()"
  },
  {
    "objectID": "01_SQL_Cleanup.html",
    "href": "01_SQL_Cleanup.html",
    "title": "SQL Cleanup",
    "section": "",
    "text": "import mysql.connector\nfrom mysql.connector import Error\nfrom nbdev.showdoc import *\n\n\ntry:\n    connection = mysql.connector.connect(user='root', host='localhost')\n    cursor = connection.cursor()\n    cursor.execute(\"\"\"\n    USE exam_db;\n    DROP TABLE temp_contact_methods;\n    DROP TABLE temp_contacts;\n    DROP TABLE temp_gifts;\n    DROP TABLE contact_methods;\n    DROP TABLE contacts;\n    DROP TABLE gifts;\n    \"\"\")\nexcept Error as e:\n    print(f\"Error: {e}\")\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()"
  },
  {
    "objectID": "02_Pandas_Solution.html",
    "href": "02_Pandas_Solution.html",
    "title": "Python Solution",
    "section": "",
    "text": "Pandas :)\n\n\n\nDoes someone want to be private   - Source Table: Contacts Table - Solution: - Create procedure to add new column Private\n\nLooking for notes\n\ncontacts.Remarks[~contacts.Remarks.isin([''])]\n\n0                                 Is anonymous\n6    Met in person on 5/9/2018 at Annual Event\n8                      Electronic receipt only\nName: Remarks, dtype: object\n\n\n\ncontacts['Private'] = contacts.Remarks.apply(lambda x: True if x == 'Is anonymous' else False)\n\n\n\n\n\nis required and can only be Household or Organization   - Source Table: Contacts Table - Solution: - Create procedure to add new column ContactType\n\n\ncontacts[['Number', 'CompanyName']]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\n\n\n\n\n0\n653377813-7\n\n\n\n1\n390551098-7\n\n\n\n2\n093004505-X\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n4\n488464926-5\n\n\n\n5\n315297729-8\n\n\n\n6\n848348568-0\n\n\n\n7\n029456846-8\n\n\n\n8\n687119652-8\n\n\n\n9\n739131380-7\n\n\n\n10\n809975531-Y\n\n\n\n\n\n\n\n\n\ncontacts['ContactType'] = contacts.apply(lambda x: 'Household' if x['CompanyName'] == '' else 'Organization', axis=1)\n\n\ncontacts[['Number', 'CompanyName', 'ContactType']].head(3)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nContactType\n\n\n\n\n0\n653377813-7\n\nHousehold\n\n\n1\n390551098-7\n\nHousehold\n\n\n2\n093004505-X\n\nHousehold\n\n\n\n\n\n\n\n\n\n\n\nif address is present and is US, must be a valid zip code, either 12345 or 12345-1234   - Source Table: Contacts  - Solution:  - Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\n\ncontacts['Postal'].head(3)\n\n0    20535-871\n1        89130\n2             \nName: Postal, dtype: object\n\n\n\npostal_code_pattern = '[0-9]{5}(?:-[0-9]{4})?$'\n\n\ncontacts['Postal'] = contacts.Postal.apply(lambda x: x if re.match(postal_code_pattern, x) else '')\n\n\ncontacts['Postal'].head(3)\n\n0         \n1    89130\n2         \nName: Postal, dtype: object\n\n\n\n\n\n\ncan only be TRUE or FALSE   - Source Table: Contacts  - Solution:  - Create procedure to update Deceased to TRUE/FALSE\n\n\ncontacts.Deceased.head(3)\n\n0    \n1    \n2    \nName: Deceased, dtype: object\n\n\n\ncontacts['Deceased'] = contacts.Deceased.apply(lambda x: True if x == 'Yes' else False)\n\n\ncontacts.Deceased.head(3)\n\n0    False\n1    False\n2    False\nName: Deceased, dtype: bool\n\n\n\n\n\n\nCan only be Cash, Check, Credit, Other, or Reversing Transaction   - Source Table: Gifts  - Solution:  - Identify Incorrect Gift Types  - Create procedure to replace invalid gift types \n\n\ngifts[['AmountReceived', 'PaymentMethod']].tail(10)\n\n\n\n\n\n\n\n\nAmountReceived\nPaymentMethod\n\n\n\n\n21\n4.21\ncredit card\n\n\n22\n9.28\ncash\n\n\n23\n2.74\nPayPal\n\n\n24\n9.00\nmoney order\n\n\n25\n1.88\ncash\n\n\n26\n-6.76\ncheck\n\n\n27\n7.58\ncredit card\n\n\n28\n5.49\ncash\n\n\n29\n8.93\nmoney order\n\n\n30\n2.62\ncredit card\n\n\n\n\n\n\n\n\ndef clean_payment_type(row):\n    payment_method = ''\n    orginal_payment_method = str(row['PaymentMethod']).lower()\n    \n    if row['AmountReceived'] &lt; 0:\n        payment_method = 'Reversing Transaction'\n    elif re.match('credit', orginal_payment_method):\n        payment_method = 'Credit'\n    elif orginal_payment_method in ['check', 'cash', 'reversing transaction']:\n        payment_method = orginal_payment_method.title()\n    else:\n        payment_method = 'Other'\n\n    return payment_method\n\n\nsource\n\n\n\n clean_payment_type (row)\n\n\n\n\n\n\ngifts['PaymentMethod'] = gifts.apply(clean_payment_type, axis=1)\n\n\ngifts.PaymentMethod.tail(10)\n\n21                   Credit\n22                     Cash\n23                    Other\n24                    Other\n25                     Cash\n26    Reversing Transaction\n27                   Credit\n28                     Cash\n29                    Other\n30                   Credit\nName: PaymentMethod, dtype: object\n\n\n\n\n\n\nCan only be Visa, Mastercard, AMEX, Discover   - Solution:  - Identify Incorrect Credit Types  - Create procedure to replace invalid credit types\n\n\ngifts.CreditCardType.unique()\n\narray(['', 'American Ex', 'AMEX', 'Visa', 'Master card', 'Mastercard',\n       'Discover'], dtype=object)\n\n\nCreating functions to validate each of the credit card types\n\nsource\n\n\n\n validate_mastercard (string)\n\n\nsource\n\n\n\n\n validate_amex (string)\n\n\nsource\n\n\n\n\n validate_visa (string)\n\n\nsource\n\n\n\n\n validate_discover (string)\n\n\ndef validate_credit_card(string): \n    if validate_mastercard(string):\n        return 'Mastercard'\n    elif validate_amex(string):\n        return 'AMEX'\n    elif validate_visa(string):\n        return 'Visa'\n    elif validate_discover(string):\n        return 'Discover'\n    else:\n        return ''\n\n\nsource\n\n\n\n\n validate_credit_card (string)\n\n\n\n\n\n\ngifts['CreditCardType'] = gifts.CreditCardType.apply(validate_credit_card)"
  },
  {
    "objectID": "02_Pandas_Solution.html#private",
    "href": "02_Pandas_Solution.html#private",
    "title": "Python Solution",
    "section": "",
    "text": "Does someone want to be private   - Source Table: Contacts Table - Solution: - Create procedure to add new column Private\n\nLooking for notes\n\ncontacts.Remarks[~contacts.Remarks.isin([''])]\n\n0                                 Is anonymous\n6    Met in person on 5/9/2018 at Annual Event\n8                      Electronic receipt only\nName: Remarks, dtype: object\n\n\n\ncontacts['Private'] = contacts.Remarks.apply(lambda x: True if x == 'Is anonymous' else False)"
  },
  {
    "objectID": "02_Pandas_Solution.html#contacttype",
    "href": "02_Pandas_Solution.html#contacttype",
    "title": "Python Solution",
    "section": "",
    "text": "is required and can only be Household or Organization   - Source Table: Contacts Table - Solution: - Create procedure to add new column ContactType\n\n\ncontacts[['Number', 'CompanyName']]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\n\n\n\n\n0\n653377813-7\n\n\n\n1\n390551098-7\n\n\n\n2\n093004505-X\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n4\n488464926-5\n\n\n\n5\n315297729-8\n\n\n\n6\n848348568-0\n\n\n\n7\n029456846-8\n\n\n\n8\n687119652-8\n\n\n\n9\n739131380-7\n\n\n\n10\n809975531-Y\n\n\n\n\n\n\n\n\n\ncontacts['ContactType'] = contacts.apply(lambda x: 'Household' if x['CompanyName'] == '' else 'Organization', axis=1)\n\n\ncontacts[['Number', 'CompanyName', 'ContactType']].head(3)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nContactType\n\n\n\n\n0\n653377813-7\n\nHousehold\n\n\n1\n390551098-7\n\nHousehold\n\n\n2\n093004505-X\n\nHousehold"
  },
  {
    "objectID": "02_Pandas_Solution.html#postal-code",
    "href": "02_Pandas_Solution.html#postal-code",
    "title": "Python Solution",
    "section": "",
    "text": "if address is present and is US, must be a valid zip code, either 12345 or 12345-1234   - Source Table: Contacts  - Solution:  - Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\n\ncontacts['Postal'].head(3)\n\n0    20535-871\n1        89130\n2             \nName: Postal, dtype: object\n\n\n\npostal_code_pattern = '[0-9]{5}(?:-[0-9]{4})?$'\n\n\ncontacts['Postal'] = contacts.Postal.apply(lambda x: x if re.match(postal_code_pattern, x) else '')\n\n\ncontacts['Postal'].head(3)\n\n0         \n1    89130\n2         \nName: Postal, dtype: object"
  },
  {
    "objectID": "02_Pandas_Solution.html#isdeceased",
    "href": "02_Pandas_Solution.html#isdeceased",
    "title": "Python Solution",
    "section": "",
    "text": "can only be TRUE or FALSE   - Source Table: Contacts  - Solution:  - Create procedure to update Deceased to TRUE/FALSE\n\n\ncontacts.Deceased.head(3)\n\n0    \n1    \n2    \nName: Deceased, dtype: object\n\n\n\ncontacts['Deceased'] = contacts.Deceased.apply(lambda x: True if x == 'Yes' else False)\n\n\ncontacts.Deceased.head(3)\n\n0    False\n1    False\n2    False\nName: Deceased, dtype: bool"
  },
  {
    "objectID": "02_Pandas_Solution.html#gifttype",
    "href": "02_Pandas_Solution.html#gifttype",
    "title": "Python Solution",
    "section": "",
    "text": "Can only be Cash, Check, Credit, Other, or Reversing Transaction   - Source Table: Gifts  - Solution:  - Identify Incorrect Gift Types  - Create procedure to replace invalid gift types \n\n\ngifts[['AmountReceived', 'PaymentMethod']].tail(10)\n\n\n\n\n\n\n\n\nAmountReceived\nPaymentMethod\n\n\n\n\n21\n4.21\ncredit card\n\n\n22\n9.28\ncash\n\n\n23\n2.74\nPayPal\n\n\n24\n9.00\nmoney order\n\n\n25\n1.88\ncash\n\n\n26\n-6.76\ncheck\n\n\n27\n7.58\ncredit card\n\n\n28\n5.49\ncash\n\n\n29\n8.93\nmoney order\n\n\n30\n2.62\ncredit card\n\n\n\n\n\n\n\n\ndef clean_payment_type(row):\n    payment_method = ''\n    orginal_payment_method = str(row['PaymentMethod']).lower()\n    \n    if row['AmountReceived'] &lt; 0:\n        payment_method = 'Reversing Transaction'\n    elif re.match('credit', orginal_payment_method):\n        payment_method = 'Credit'\n    elif orginal_payment_method in ['check', 'cash', 'reversing transaction']:\n        payment_method = orginal_payment_method.title()\n    else:\n        payment_method = 'Other'\n\n    return payment_method\n\n\nsource\n\n\n\n clean_payment_type (row)"
  },
  {
    "objectID": "02_Pandas_Solution.html#applying-gifttype-transformation",
    "href": "02_Pandas_Solution.html#applying-gifttype-transformation",
    "title": "Python Solution",
    "section": "",
    "text": "gifts['PaymentMethod'] = gifts.apply(clean_payment_type, axis=1)\n\n\ngifts.PaymentMethod.tail(10)\n\n21                   Credit\n22                     Cash\n23                    Other\n24                    Other\n25                     Cash\n26    Reversing Transaction\n27                   Credit\n28                     Cash\n29                    Other\n30                   Credit\nName: PaymentMethod, dtype: object"
  },
  {
    "objectID": "02_Pandas_Solution.html#creditcardtype",
    "href": "02_Pandas_Solution.html#creditcardtype",
    "title": "Python Solution",
    "section": "",
    "text": "Can only be Visa, Mastercard, AMEX, Discover   - Solution:  - Identify Incorrect Credit Types  - Create procedure to replace invalid credit types\n\n\ngifts.CreditCardType.unique()\n\narray(['', 'American Ex', 'AMEX', 'Visa', 'Master card', 'Mastercard',\n       'Discover'], dtype=object)\n\n\nCreating functions to validate each of the credit card types\n\nsource\n\n\n\n validate_mastercard (string)\n\n\nsource\n\n\n\n\n validate_amex (string)\n\n\nsource\n\n\n\n\n validate_visa (string)\n\n\nsource\n\n\n\n\n validate_discover (string)\n\n\ndef validate_credit_card(string): \n    if validate_mastercard(string):\n        return 'Mastercard'\n    elif validate_amex(string):\n        return 'AMEX'\n    elif validate_visa(string):\n        return 'Visa'\n    elif validate_discover(string):\n        return 'Discover'\n    else:\n        return ''\n\n\nsource\n\n\n\n\n validate_credit_card (string)"
  },
  {
    "objectID": "02_Pandas_Solution.html#applying-creditcardtype-transformation",
    "href": "02_Pandas_Solution.html#applying-creditcardtype-transformation",
    "title": "Python Solution",
    "section": "",
    "text": "gifts['CreditCardType'] = gifts.CreditCardType.apply(validate_credit_card)"
  },
  {
    "objectID": "02_Pandas_Solution.html#contact-methods",
    "href": "02_Pandas_Solution.html#contact-methods",
    "title": "Python Solution",
    "section": "Contact Methods",
    "text": "Contact Methods\n\nTable of constituent contact information\n\nMerging Contact and Contact Methods Tables To get ALL the contact information\n\ntemp_contacts = contacts[['Number', 'Phone', 'EMail']].rename(columns={\n    'Number': 'LegacyContactId',\n    'Phone': 'HomePhone',\n    'EMail': 'HomeEmail'\n}).copy()\n\n\ntemp_contact_methods = contact_methods.rename(columns={'DonorNumber':'LegacyContactId'})\n\n\ncontacts_wide = temp_contacts.merge(temp_contact_methods,\n                                how='left',\n                                on='LegacyContactId',\n                                ).sort_values('LegacyContactId')\n\nPivoting the Data, converting the HomePhone, HomeEmail, And Fax values to individual Type : Value pairs\n\ncontacts_v = contacts_wide.melt(id_vars=['LegacyContactId'], value_vars=['HomePhone', 'HomeEmail', 'Fax', 'Phone', 'EMail'], var_name='Type', value_name='Value')\n\nCreating a function to safley check for nan values\n\ndef is_nan(x):\n    try:\n        return np.isnan(x)\n    except TypeError:\n        return False\n\n\nfinal_contact_methods = contacts_v[~((contacts_v.Value == '') | (contacts_v.Value.apply(is_nan)))].reset_index(drop=True).copy()\n\n\ndef clean_contact_type(s):\n    if s == 'Phone':\n        return 'HomePhone'\n    elif s == 'EMail':\n        return 'HomeEmail'\n    else:\n        return s\n\n\nfinal_contact_methods['Type'] = final_contact_methods.Type.apply(clean_contact_type)\n\n\nfinal_contact_methods.drop_duplicates(inplace=True)\n\n\nfinal_contact_methods.sort_values('LegacyContactId').reset_index(drop=True)\n\n\n\n\n\n\n\n\nLegacyContactId\nType\nValue\n\n\n\n\n0\n029456846-8\nHomeEmail\njdoley6@telegraph.co.uk\n\n\n1\n093004505-X\nFax\n818-156-7985\n\n\n2\n093004505-X\nHomePhone\n818-323-9865\n\n\n3\n315297729-8\nHomeEmail\ndmouncey9@cnn.com\n\n\n4\n390551098-7\nHomeEmail\nebenech1@goodreads.com\n\n\n5\n488464926-5\nHomeEmail\nfcastille4@timesonline.co.uk\n\n\n6\n653377813-7\nHomeEmail\nkklumbers@yahoo.com\n\n\n7\n653377813-7\nHomePhone\n832-442-4988\n\n\n8\n687119652-8\nHomeEmail\ncmakepeace7@1688.com\n\n\n9\n739131380-7\nFax\n626-981-3874\n\n\n10\n848348568-0\nHomePhone\n702-844-9524\n\n\n\n\n\n\n\n\n\nfinal_contact_methods.to_csv('data/final_contact_methods.csv', index=False)"
  },
  {
    "objectID": "02_Pandas_Solution.html#contacts",
    "href": "02_Pandas_Solution.html#contacts",
    "title": "Python Solution",
    "section": "Contacts",
    "text": "Contacts\n\nTable of constituent contact information\n\nChecking for any missing contacts\n\ndef is_empty(x):\n    if str(x) == '' or str(x) == 'nan':\n        return True\n    else:\n        return False\n\n\ndef format_string(x):\n    if is_empty(x):\n        return ''\n    else: \n        return x\n\n\ncontacts_wide['HomePhone'] = np.where(contacts_wide['HomePhone'].apply(is_empty), format_string(contacts_wide['Phone']), format_string(contacts_wide['HomePhone']))\ncontacts_wide['HomeEmail'] = np.where(contacts_wide['HomeEmail'].apply(is_empty), format_string(contacts_wide['EMail']), format_string(contacts_wide['HomeEmail']))\n\n\ncontacts_wide = contacts_wide[['LegacyContactId', 'HomePhone', 'HomeEmail']].fillna('').copy()\n\n\ncontacts_wide = contacts_wide[~((contacts_wide.HomePhone == '') & (contacts_wide.HomeEmail == ''))].copy()\n\n\ncontacts = (contacts\n            .drop(['Phone', 'EMail'], axis=1)\n            .merge(contacts_wide,\n                   left_on='Number',\n                   right_on='LegacyContactId',\n                   how='left',\n            )\n            .drop('LegacyContactId', axis=1)\n            )\n\n\ncolumns = [\n    'LegacyContactId', 'LegacyIndividualId', 'ContactType', 'ContactName',\n    'FirstName', \n    'LastName', 'SecondaryLegacyIndividualId', 'SecondaryFirstName',\n    'SecondaryLastName', 'HomePhone', 'HomeEmail', 'Address1', \n    'City', 'State', 'PostalCode', 'IsPrivate', 'IsDeceased',\n    ]\n\n\ncontacts.rename(columns={\n    'Number':'LegacyContactId',\n    'Street': 'Address1',\n    'Postal': 'PostalCode',\n    'Private': 'IsPrivate',\n    'Deceased': 'IsDeceased',\n}, inplace=True)\n\n\nfinal_contacts = contacts[columns].fillna('')\n\n\nfinal_contacts\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyIndividualId\nContactType\nContactName\nFirstName\nLastName\nSecondaryLegacyIndividualId\nSecondaryFirstName\nSecondaryLastName\nHomePhone\nHomeEmail\nAddress1\nCity\nState\nPostalCode\nIsPrivate\nIsDeceased\n\n\n\n\n0\n653377813-7\n0\nHousehold\nKarita & Kelvin Lumbers\nKarita\nLumbers\n1\nKelvin\nLumbers\n832-442-4988\nkklumbers@yahoo.com\n4 Bunting Parkway\nWashington\nDC\n\nTrue\nFalse\n\n\n1\n390551098-7\n2\nHousehold\nHelga Benech\nHelga\nBenech\n\n\n\n\nebenech1@goodreads.com\n48684 Jenifer Way\nLas Vegas\nNV\n89130\nFalse\nFalse\n\n\n2\n093004505-X\n3\nHousehold\nMasha Butt Gow\nMasha\nButt Gow\n\n\n\n818-323-9865\n\n353 Schmedeman Park\nIndianapolis\nIN\n\nFalse\nFalse\n\n\n3\n729707142-0\n4\nOrganization\nCymbre Cross\nCymbre\nCross\n\n\n\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n\nFalse\nFalse\n\n\n4\n488464926-5\n5\nHousehold\nHoyt Castille\nHoyt\nCastille\n\n\n\n\nfcastille4@timesonline.co.uk\n37 8th Trail\nGrand Rapids\nMI\n49560\nFalse\nFalse\n\n\n5\n315297729-8\n6\nHousehold\nBenedict Oscar & Idell Mouncey\nBenedict\nOscar\n7\nIdell\nMouncey\n\ndmouncey9@cnn.com\n4225 Madison Ave\nBoise\nID\n\nFalse\nFalse\n\n\n6\n848348568-0\n8\nHousehold\nMannie Turpin\nMannie\nTurpin\n\n\n\n702-844-9524\n\n\n\nNV\n\nFalse\nTrue\n\n\n7\n029456846-8\n9\nHousehold\nRomy Doley\nRomy\nDoley\n\n\n\n\njdoley6@telegraph.co.uk\n608 Old Shore Alley\nMarietta\nGA\n30066\nFalse\nFalse\n\n\n8\n687119652-8\n10\nHousehold\nRuggiero Makepeace\nRuggiero\nMakepeace\n\n\n\n\ncmakepeace7@1688.com\n15 Sunbrook Center\nOmaha\nNE\n68164\nFalse\nFalse\n\n\n9\n739131380-7\n11\nHousehold\nRosemaria & Rogelio Dimond\nRosemaria\nDimond\n12\nRogelio\nDimond\n\n\n\nJuneau\nAK\n\nFalse\nFalse\n\n\n10\n809975531-Y\n13\nHousehold\nAdeline Shakespeare\nAdeline\nShakespeare\n\n\n\n\n\n\n\n\n\nFalse\nFalse\n\n\n\n\n\n\n\n\n\nfinal_contacts.to_csv('data/final_contacts.csv', index=False)"
  },
  {
    "objectID": "02_Pandas_Solution.html#gifts",
    "href": "02_Pandas_Solution.html#gifts",
    "title": "Python Solution",
    "section": "Gifts",
    "text": "Gifts\n\nTable with gift history\n\n\ncolumns = ['LegacyContactId', 'LegacyGiftId', 'GiftType', 'GiftDate',\n           'GiftAmount', 'Notes', 'CreditCardType', 'Project1Code',\n           'Project2Code', 'LegacyPledgeID']\n\n\ngifts.rename(columns={\n    'DonorNumber': 'LegacyContactId',\n    'PaymentMethod': 'GiftType',\n    'AmountReceived': 'GiftAmount',\n}, inplace=True)\n\n\ngifts[columns]\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyGiftId\nGiftType\nGiftDate\nGiftAmount\nNotes\nCreditCardType\nProject1Code\nProject2Code\nLegacyPledgeID\n\n\n\n\n0\n848348568-0\n95196378\nOther\n2019-03-04\n4.1500\n\n\n\nNone\n0\n\n\n1\n729707142-0\n95196889\nCheck\n2019-03-05\n2.3648\n\n\nChildSponsorship\nNone\n1\n\n\n2\n687119652-8\n95197689\nCash\n2019-03-07\n1.3100\n\n\n\nNone\n2\n\n\n3\n653377813-7\n95198998\nCredit\n2019-03-10\n2.0400\nIn honor of Mannie Turpin\nAMEX\n\nNone\n3\n\n\n4\n390551098-7\n95198999\nCash\n2019-01-10\n5.8000\n\n\n\nNone\n89752384\n\n\n5\n848348568-0\n95296677\nOther\n2019-03-20\n9.2800\n\n\nGeneral\nReliefFund\n5\n\n\n6\n029456846-8\n95298831\nCheck\n2019-03-24\n5.0000\nACH check #7687\n\n\nNone\n6\n\n\n7\n093004505-X\n95298845\nCheck\n2019-04-09\n4.8300\n\n\n\nNone\n7\n\n\n8\n315297729-8\n95298997\nCheck\n2019-04-12\n7.0000\n\n\nSchoolSupplies2019\nNone\n8\n\n\n9\n809975531-Y\n9\nCredit\n2019-08-14\n8.4800\n\nAMEX\n\nNone\n9\n\n\n10\n739131380-7\n95329966\nCredit\n2019-04-13\n5.8400\n\nVisa\n\nNone\n10\n\n\n11\n739131380-7\n95330011\nOther\n2019-04-13\n7.4500\n\n\n\nNone\n11\n\n\n12\n029456846-8\n95330012\nCheck\n2019-04-17\n8.1300\n\n\nMentorship2023\nNone\n12\n\n\n13\n315297729-8\n95330110\nReversing Transaction\n2019-04-19\n-3.0100\n\n\n\nNone\n13\n\n\n14\n739131380-7\n95330662\nOther\n2019-05-10\n3.4000\n\n\n\nNone\n14\n\n\n15\n687119652-8\n95419562\nOther\n2019-06-04\n5.0700\n\n\n\nNone\n15\n\n\n16\n488464926-5\n95422266\nCash\n2019-06-05\n5.4200\n\n\nGeneralFund\nNone\n16\n\n\n17\n848348568-0\n95485564\nOther\n2019-06-10\n6.8000\n\n\n\nNone\n57398862\n\n\n18\n390551098-7\n95496635\nOther\n2019-06-11\n6.7800\n\n\n\nNone\n18\n\n\n19\n729707142-0\n95497782\nOther\n2019-06-20\n5.2700\n\n\n\nNone\n19\n\n\n20\n315297729-8\n20\nCheck\n2019-06-20\n5.5900\n\n\n\nNone\n65139856\n\n\n21\n390551098-7\n95763575\nCredit\n2019-07-01\n4.2100\n\nMastercard\n\nNone\n21\n\n\n22\n488464926-5\n95798342\nCash\n2019-07-18\n9.2800\n\n\n\nNone\n22\n\n\n23\n848348568-0\n95798343\nOther\n2019-07-01\n2.7400\n\n\n\nNone\n23\n\n\n24\n029456846-8\n95801563\nOther\n2019-08-01\n9.0000\n\n\n\nNone\n24\n\n\n25\n729707142-0\n95801564\nCash\n2019-08-03\n1.8800\n\n\n\nNone\n25\n\n\n26\n687119652-8\n95835492\nReversing Transaction\n2019-08-12\n-6.7600\n\n\n\nNone\n26\n\n\n27\n809975531-Y\n27\nCredit\n2019-08-14\n7.5800\n\nMastercard\nColor run\nChildSponsorship\n27\n\n\n28\n653377813-7\n28\nCash\n2019-08-26\n5.4900\n\n\n\nNone\n28\n\n\n29\n739131380-7\n96638462\nOther\n2019-09-01\n8.9300\n\n\nReliefFund\nNone\n29\n\n\n30\n093004505-X\n96638468\nCredit\n2019-09-06\n2.6200\n\nDiscover\n\nNone\n30\n\n\n\n\n\n\n\n\n\nfinal_gifts = gifts[columns].copy()\n\n\nfinal_gifts.to_csv('data/final_gifts.csv', index=False)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "Virtuous Data Schema, changes that require ETL have been highlighted \n\n\n\n\n\nalternative text\n\n\n\n\n\nI performed ETL of 3 spreadsheets into SQL tables & csv files that match the Virtuous schema  \n\n\nContacts: A table of contacts, with 1 or 2 constituents per row\nGifts: Donations from individual constituents\nContact Methods: Contact information for individual constituents\n\n\n\n\n\nI’ve demonstrated 3 methods of performing the data migraiton  \n\n\nSetup \nMethod 1: SQL \nMethod 2: Python / Pandas \nMethod 3: Generative AI / Chat GPT \n\n\n\n\n\nCSV files generated from the Python ETL process  \n\n\nfinal_contacts\nfinal_gifts\nfinal_contact_methods   The intial datasets are also available in the data folder\n\n\n\n\n\nIdea bananza!\n\n\n\n\nAugust 10th, 2:29 PM EST  \n\n\n\n\nEmail with assignment details\n\n\n\n\n\n\nCompleted: August 10th, 3:13 PM EST  \n\n\n\n\nRough Action Plan\n\n\n\n\n\n\nI got a little carried away  \n\nSometimes I can’t help myself! I love working with data. Finding new & interesting ways to solve problems is something I’m naturally passionate about   The downside? I tend to wander a little too close to the sun…   While this project was simply to migrate the data to tables compatible with the Virtuous schema, I felt a deep desire to do more. To go above & beyond. While I pride myself on adapting to the needs of a team, the desire to grow and change is core to who I am. And I believe it’s a valuable asset to a great team.   I promise to do what’s best for the team.  And I also promise to always push the boundries of what’s possible"
  },
  {
    "objectID": "index.html#summary",
    "href": "index.html#summary",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "I performed ETL of 3 spreadsheets into SQL tables & csv files that match the Virtuous schema  \n\n\nContacts: A table of contacts, with 1 or 2 constituents per row\nGifts: Donations from individual constituents\nContact Methods: Contact information for individual constituents"
  },
  {
    "objectID": "index.html#notebooks",
    "href": "index.html#notebooks",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "I’ve demonstrated 3 methods of performing the data migraiton  \n\n\nSetup \nMethod 1: SQL \nMethod 2: Python / Pandas \nMethod 3: Generative AI / Chat GPT"
  },
  {
    "objectID": "index.html#result",
    "href": "index.html#result",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "CSV files generated from the Python ETL process  \n\n\nfinal_contacts\nfinal_gifts\nfinal_contact_methods   The intial datasets are also available in the data folder"
  },
  {
    "objectID": "index.html#my-approach",
    "href": "index.html#my-approach",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "Idea bananza!\n\n\n\n\nAugust 10th, 2:29 PM EST  \n\n\n\n\nEmail with assignment details\n\n\n\n\n\n\nCompleted: August 10th, 3:13 PM EST  \n\n\n\n\nRough Action Plan\n\n\n\n\n\n\nI got a little carried away  \n\nSometimes I can’t help myself! I love working with data. Finding new & interesting ways to solve problems is something I’m naturally passionate about   The downside? I tend to wander a little too close to the sun…   While this project was simply to migrate the data to tables compatible with the Virtuous schema, I felt a deep desire to do more. To go above & beyond. While I pride myself on adapting to the needs of a team, the desire to grow and change is core to who I am. And I believe it’s a valuable asset to a great team.   I promise to do what’s best for the team.  And I also promise to always push the boundries of what’s possible"
  }
]