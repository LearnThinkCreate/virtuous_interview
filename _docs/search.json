[
  {
    "objectID": "03_Gpt_Solution.html",
    "href": "03_Gpt_Solution.html",
    "title": "GPT Solution",
    "section": "",
    "text": "openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\n\nsource\n\n\n\n GptPrompt (messages)\n\nClass For sending messages to Open AI using GPT-3.5 Turbo 16k 0613"
  },
  {
    "objectID": "03_Gpt_Solution.html#configuring-openai-credentials",
    "href": "03_Gpt_Solution.html#configuring-openai-credentials",
    "title": "GPT Solution",
    "section": "",
    "text": "openai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\n\nsource\n\n\n\n GptPrompt (messages)\n\nClass For sending messages to Open AI using GPT-3.5 Turbo 16k 0613"
  },
  {
    "objectID": "03_Gpt_Solution.html#creditcardtype",
    "href": "03_Gpt_Solution.html#creditcardtype",
    "title": "GPT Solution",
    "section": "CreditCardType",
    "text": "CreditCardType\n\nCan only be Visa, Mastercard, AMEX, Discover  - Solution:  - Asking Chat GPT to format the unique CreditCardTypes into the pre-approved list of values \n\n\ncredit_card_prompt =[ \n    {\n      \"role\": \"system\",\n      \"content\": \"\"\"\n      You will be given a comma separated list of items. \n      Each item is supposed to be a unique credit card type taken from a column on a database table. \n      The only acceptable credit card types are [Visa, Mastercard, AMEX, Discover]\n      Your job is to examine each item in the list to see if it matches one of the acceptable credit card types or not.\n      For each item in the list that is not ALREADY in the list of acceptable credit card types you will need to provide which credit card type it matches with. \n      If a item doesn't match ANY of the acceptable credit card types [Visa, Mastercard, AMEX, Discover] then match it with an empty string ''\n      Format your response in JSON\n      \"\"\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"Americn Ex,AMEX,Visa,Master car,Mastercard,Discover,Jazz\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"\"\"{\n              \"Americn Ex\": \"AMEX\",\n              \"Master car\": \"Mastercard\",\n              \"Jazz\":\"\"\n          }\n          \"\"\"\n    },\n]\n\n\nCreditCardCleaner = GptPrompt(messages=credit_card_prompt)\n\n\nvalues_to_replace = CreditCardCleaner.call_gpt(to_csl(gifts['CreditCardType']))\n\n\nvalues_to_replace\n\n{'American Ex': 'AMEX', 'Master card': 'Mastercard', '': ''}\n\n\n\ngifts['CreditCardType'] = gifts['CreditCardType'].replace(values_to_replace)"
  },
  {
    "objectID": "03_Gpt_Solution.html#gifttype",
    "href": "03_Gpt_Solution.html#gifttype",
    "title": "GPT Solution",
    "section": "GiftType",
    "text": "GiftType\n\nCan only be Cash, Check, Credit, Other, or Reversing Transaction   - Solution:  - Asking Chat GPT to format the unique GiftTypes into the pre-approved list of values  - Replace ‘Reversing Transaction’ using simple logic in Python \n\n\ngift_type_prompt = [\n        {\n          \"role\": \"system\",\n          \"content\": \"\"\"\n          You will be given a comma separated list of items. \n          Each item is supposed to be a unique payment method taken from a column on a database table. \n          The only acceptable payment methods are [Cash, Check, Credit, or Other]\n          Your job is to examine each item in the list to see if it matches one of the acceptable payment methods or not. If it doesn't map to \n          For each item in the list that is not ALREADY in the list of acceptable payment method  you will need to provide which payment method  type it matches with\n          Format your response in JSON\n          \"\"\"\n        },\n        {\n          \"role\": \"user\",\n          \"content\": \"$,cash,Credit,AMEX,Square\"\n        },\n        {\n          \"role\": \"assistant\",\n          \"content\": \"\"\"{\n                  \"$: \"Cash\",\n                  \"cash: \"Cash\",\n                  \"AMEX\":\"Credit\",\n                  \"Square\":\"Other\",\n                  \n              }\n              \"\"\"\n        },\n      ]\n\n\nGiftTypeCleaner = GptPrompt(messages=gift_type_prompt)\n\n\nvalues_to_replace = GiftTypeCleaner.call_gpt(to_csl(gifts['PaymentMethod']))\nvalues_to_replace[''] = 'Other'\n\n\nvalues_to_replace\n\n{'PayPal': 'Other',\n 'check': 'Check',\n 'cash': 'Cash',\n 'credit card': 'Credit',\n 'money order': 'Other',\n '': 'Other'}\n\n\n\ngifts.apply(lambda row: 'Reversing Transaction' if row['AmountReceived'] &lt; 0 else values_to_replace[row['PaymentMethod']], axis=1)\n\n0                     Other\n1                     Check\n2                      Cash\n3                    Credit\n4                      Cash\n5                     Other\n6                     Check\n7                     Check\n8                     Check\n9                    Credit\n10                   Credit\n11                    Other\n12                    Check\n13    Reversing Transaction\n14                    Other\n15                    Other\n16                     Cash\n17                    Other\n18                    Other\n19                    Other\n20                    Check\n21                   Credit\n22                     Cash\n23                    Other\n24                    Other\n25                     Cash\n26    Reversing Transaction\n27                   Credit\n28                     Cash\n29                    Other\n30                   Credit\ndtype: object"
  },
  {
    "objectID": "03_Gpt_Solution.html#contacttype",
    "href": "03_Gpt_Solution.html#contacttype",
    "title": "GPT Solution",
    "section": "ContactType",
    "text": "ContactType\n`is required and can only be Household or Organization   - Source Table: Contacts Table  - Solution:  - Create procedure to add new column ContactType \n\ndf = contacts.copy()\ngpt_response = df.ask(\"create a new column called ContactType. The value is required and can only be either Household or Organization. If CompanyName is '' assume it's a household\")\ngpt_response[['Number', 'CompanyName', 'ContactType']].head(5)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nContactType\n\n\n\n\n0\n653377813-7\n\nHousehold\n\n\n1\n390551098-7\n\nHousehold\n\n\n2\n093004505-X\n\nHousehold\n\n\n3\n729707142-0\nA Company Co.\nOrganization\n\n\n4\n488464926-5\n\nHousehold"
  },
  {
    "objectID": "03_Gpt_Solution.html#postal-code",
    "href": "03_Gpt_Solution.html#postal-code",
    "title": "GPT Solution",
    "section": "Postal Code",
    "text": "Postal Code\n\nif address is present and is US, must be a valid zip code, either 12345 or 12345-1234   - Source Table: Contacts - Solution: - Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\n\ncontacts[['Postal']]\n\n\n\n\n\n\n\n\nPostal\n\n\n\n\n0\n20535-871\n\n\n1\n89130\n\n\n2\n\n\n\n3\n8104\n\n\n4\n49560\n\n\n5\n837016\n\n\n6\n\n\n\n7\n30066\n\n\n8\n68164\n\n\n9\n\n\n\n10\n\n\n\n\n\n\n\n\n\ndf = contacts.copy()\ngpt_response = df.ask(\"Clean the Postal Column. If address is present and is US, must be a valid zip code, either 12345 or 12345-1234. Don't delete rows with an invalid zip, just replace the invalid zip with ''\")\ngpt_response[['Postal']]\n\n\n\n\n\n\n\n\nPostal\n\n\n\n\n0\n\n\n\n1\n89130-\n\n\n2\n\n\n\n3\n\n\n\n4\n49560-\n\n\n5\n\n\n\n6\n\n\n\n7\n30066-\n\n\n8\n68164-\n\n\n9\n\n\n\n10"
  },
  {
    "objectID": "03_Gpt_Solution.html#isdeceased",
    "href": "03_Gpt_Solution.html#isdeceased",
    "title": "GPT Solution",
    "section": "IsDeceased",
    "text": "IsDeceased\n\ncan only be TRUE or FALSE   - Source Table: Contacts  - Solution:  - Create procedure to update Deceased to TRUE/FALSE \n\n\ngpt_response.Deceased.unique()\n\narray(['', 'No', 'Yes'], dtype=object)\n\n\n\ndf = contacts.copy()\ngpt_response = df.ask('Can you convert the Deceased column to a boolean. Assume empty strings '' are False')\ngpt_response.Deceased.unique()\n\n  Number CompanyName  ... SecondaryLegacyIndividualId ContactName\n0      1         ABC  ...                                        \n1      2         DEF  ...                                        \n2      3         GHI  ...                                        \n3      4         JKL  ...                                        \n4      5         MNO  ...                                        \n\n[5 rows x 17 columns]\n\n\narray([False,  True])"
  },
  {
    "objectID": "01_SQL_Solution.html",
    "href": "01_SQL_Solution.html",
    "title": "SQL Solution",
    "section": "",
    "text": "Creating a new db instance and loading tables\n\n\n\n\nDB_NAME = 'exam_db'\n\nUsing mysql library to connect as root user and create a new db instance\n\ntry:\n    connection = mysql.connector.connect(user='root', host='localhost')\n    cursor = connection.cursor()\n    cursor.execute(f\"CREATE DATABASE IF NOT EXISTS {DB_NAME};\")\nexcept Error as e:\n    print(f\"Error: {e}\")\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()\n\nSince that was a lot of code just to execute 1 line of SQL, I’m going to create a new function that will make it easier\n\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\n\n\nsource\n\n\n\n insert_sql (sql, hide_output=False)\n\nInserts data into the MySQL database.\n\nsource\n\n\n\n\n insert_proc (sql, proc_name, call=True, hide_output=False)\n\nCreate a stored procedure and call it\n\n\n\n\n\nUsing prefix ‘temp_’\n\nMapping DataFrames to table names\n\ntables = {'temp_contact_methods': contact_methods, 'temp_contacts': contacts, 'temp_gifts': gifts}\n\n\nengine = create_engine(f'mysql+mysqlconnector://{DB_USER}:{DB_PASSWORD}@localhost/{DB_NAME}')\n\n\ntry:\n    for table_name, df in tables.items():\n        try:\n            df.to_sql(table_name, engine, index=False, if_exists='fail')\n        except ValueError:\n            print(f\"Table {table_name} already exists. Skipping.\")\n\nexcept Error as e:\n    print(f\"Error: {e}\")\n\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()\n\nTable temp_contact_methods already exists. Skipping.\nTable temp_contacts already exists. Skipping.\nTable temp_gifts already exists. Skipping.\n\n\nPreviewing the data\n\npd.read_sql('select * from temp_gifts limit 5', engine)\n\n\n\n\n\n\n\n\nDonorNumber\nLegacyGiftId\nFirstName\nLastName\nAmountReceived\nCreditCardType\nPaymentMethod\nLegacyPledgeID\nNotes\nProject1Code\nProject2Code\nGiftDate\n\n\n\n\n0\n848348568-0\n95196378\nMannie\nTurpin\n4.1500\n\nPayPal\n0\n\n\nNone\n2019-03-04\n\n\n1\n729707142-0\n95196889\nCymbre\nCross\n2.3648\n\ncheck\n1\n\nChildSponsorship\nNone\n2019-03-05\n\n\n2\n687119652-8\n95197689\nRuggiero\nMakepeace\n1.3100\n\ncash\n2\n\n\nNone\n2019-03-07\n\n\n3\n653377813-7\n95198998\nKarita\nLumbers\n2.0400\nAmerican Ex\ncredit card\n3\nIn honor of Mannie Turpin\n\nNone\n2019-03-10\n\n\n4\n390551098-7\n95198999\nHelga\nBenech\n5.8000\n\ncash\n89752384\n\n\nNone\n2019-01-10"
  },
  {
    "objectID": "01_SQL_Solution.html#creating-db",
    "href": "01_SQL_Solution.html#creating-db",
    "title": "SQL Solution",
    "section": "",
    "text": "DB_NAME = 'exam_db'\n\nUsing mysql library to connect as root user and create a new db instance\n\ntry:\n    connection = mysql.connector.connect(user='root', host='localhost')\n    cursor = connection.cursor()\n    cursor.execute(f\"CREATE DATABASE IF NOT EXISTS {DB_NAME};\")\nexcept Error as e:\n    print(f\"Error: {e}\")\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()\n\nSince that was a lot of code just to execute 1 line of SQL, I’m going to create a new function that will make it easier\n\nDB_USER = os.getenv(\"DB_USER\")\nDB_PASSWORD = os.getenv(\"DB_PASSWORD\")\n\n\nsource\n\n\n\n insert_sql (sql, hide_output=False)\n\nInserts data into the MySQL database.\n\nsource\n\n\n\n\n insert_proc (sql, proc_name, call=True, hide_output=False)\n\nCreate a stored procedure and call it"
  },
  {
    "objectID": "01_SQL_Solution.html#loading-datasets-into-database",
    "href": "01_SQL_Solution.html#loading-datasets-into-database",
    "title": "SQL Solution",
    "section": "",
    "text": "Using prefix ‘temp_’\n\nMapping DataFrames to table names\n\ntables = {'temp_contact_methods': contact_methods, 'temp_contacts': contacts, 'temp_gifts': gifts}\n\n\nengine = create_engine(f'mysql+mysqlconnector://{DB_USER}:{DB_PASSWORD}@localhost/{DB_NAME}')\n\n\ntry:\n    for table_name, df in tables.items():\n        try:\n            df.to_sql(table_name, engine, index=False, if_exists='fail')\n        except ValueError:\n            print(f\"Table {table_name} already exists. Skipping.\")\n\nexcept Error as e:\n    print(f\"Error: {e}\")\n\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()\n\nTable temp_contact_methods already exists. Skipping.\nTable temp_contacts already exists. Skipping.\nTable temp_gifts already exists. Skipping.\n\n\nPreviewing the data\n\npd.read_sql('select * from temp_gifts limit 5', engine)\n\n\n\n\n\n\n\n\nDonorNumber\nLegacyGiftId\nFirstName\nLastName\nAmountReceived\nCreditCardType\nPaymentMethod\nLegacyPledgeID\nNotes\nProject1Code\nProject2Code\nGiftDate\n\n\n\n\n0\n848348568-0\n95196378\nMannie\nTurpin\n4.1500\n\nPayPal\n0\n\n\nNone\n2019-03-04\n\n\n1\n729707142-0\n95196889\nCymbre\nCross\n2.3648\n\ncheck\n1\n\nChildSponsorship\nNone\n2019-03-05\n\n\n2\n687119652-8\n95197689\nRuggiero\nMakepeace\n1.3100\n\ncash\n2\n\n\nNone\n2019-03-07\n\n\n3\n653377813-7\n95198998\nKarita\nLumbers\n2.0400\nAmerican Ex\ncredit card\n3\nIn honor of Mannie Turpin\n\nNone\n2019-03-10\n\n\n4\n390551098-7\n95198999\nHelga\nBenech\n5.8000\n\ncash\n89752384\n\n\nNone\n2019-01-10"
  },
  {
    "objectID": "01_SQL_Solution.html#contacttype",
    "href": "01_SQL_Solution.html#contacttype",
    "title": "SQL Solution",
    "section": "ContactType",
    "text": "ContactType\n\nis required and can only be Household or Organization \n\nSource Table:  - Contacts Table  \nSolution:  1. Create procedure to add new column ContactType\nI’m going to write a procedure that would perform this transformation on the temp table.   This process is going to require me to do 2 things:  1. Add a column to the table  2. Insert data into that column  \nAdding a column to a table can be a lengthy process since MySQL doesn’t provide a IF NOT EXISTS option for adding a column. \nAsa result I’m going to write 2 procedures to solve this problem:  1. add_column procedure  2. insert_contact_type procedure\n\nadd_column = \"\"\"\n    DROP PROCEDURE IF EXISTS add_column;\n    \n    \n    CREATE PROCEDURE add_column(\n        IN tableName VARCHAR(255),\n        IN columnName VARCHAR(255),\n        IN columnType VARCHAR(255)\n    )\n    BEGIN\n        DECLARE columnExists BOOLEAN DEFAULT FALSE;\n    \n        SELECT COUNT(*)\n        INTO columnExists\n        FROM information_schema.COLUMNS\n        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = tableName AND COLUMN_NAME = columnName;\n    \n        IF columnExists = 0 THEN\n            SET @sql = CONCAT('ALTER TABLE ', tableName, ' ADD COLUMN ', columnName, ' ', columnType);\n            PREPARE stmt FROM @sql;\n            EXECUTE stmt;\n            DEALLOCATE PREPARE stmt;\n        END IF;\n        COMMIT;\n    END;\n\"\"\"\ninsert_sql(add_column)\n\nMySQL connection closed\n\n\n\ninsert_contact_type = \"\"\"\n    CALL add_column('temp_contacts', 'ContactType', 'VARCHAR(255)');\n    \n    UPDATE temp_contacts\n    SET ContactType = CASE WHEN CompanyName = '' THEN 'Household' ELSE 'Organization' END;\n    COMMIT;\n\"\"\"\ninsert_proc(insert_contact_type, 'insert_contact_type', call=True)\n\nMySQL connection closed\nMySQL connection closed\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#private",
    "href": "01_SQL_Solution.html#private",
    "title": "SQL Solution",
    "section": "Private",
    "text": "Private\n\nDoes someone want to be private \n\nSource Table: - Contacts Table  \nSolution:  1. Create procedure to add new column Private\n\ninsert_private = \"\"\"\n    CALL add_column('temp_contacts', 'Private', 'TINYINT');\n\n    UPDATE temp_contacts\n    SET Private = CASE WHEN Remarks = 'Is anonymous' THEN 1 ELSE 0 END;\n    commit;\n\"\"\"\ninsert_proc(insert_private, 'insert_private', call=True)\n\nMySQL connection closed\nMySQL connection closed\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#postal-code",
    "href": "01_SQL_Solution.html#postal-code",
    "title": "SQL Solution",
    "section": "Postal Code",
    "text": "Postal Code\n\nif address is present and is US, must be a valid zip code, either 12345 or 12345-1234  \n\nSource Table: - Contacts  \nSolution: 1. Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\ncontacts_view = f\"\"\"\n    CREATE OR REPLACE VIEW contacts_view AS\n    SELECT\n        NUMBER,\n        POSTAL AS OLD_POSTAL,\n        CASE\n        WHEN REGEXP_LIKE(Postal, '^[0-9]{{5}}$') OR REGEXP_LIKE(Postal, '^[0-9]{{5}}-[0-9]{{4}}$') THEN Postal\n        ELSE ''\n        END AS NEW_POSTAL\n    FROM temp_contacts;\n\"\"\"\ninsert_sql(contacts_view)\npd.read_sql(\"SELECT * FROM contacts_view where old_postal != '' limit 5\", con=engine)\n\nMySQL connection closed\n\n\n\n\n\n\n\n\n\nNUMBER\nOLD_POSTAL\nNEW_POSTAL\n\n\n\n\n0\n653377813-7\n20535-871\n\n\n\n1\n390551098-7\n89130\n89130\n\n\n2\n729707142-0\n8104\n\n\n\n3\n488464926-5\n49560\n49560\n\n\n4\n315297729-8\n837016\n\n\n\n\n\n\n\n\nSuccess!  Creating Stored Procedure…\n\nupdate_zip = \"\"\"\n    UPDATE temp_contacts\n    SET Postal = ''\n    WHERE Postal NOT REGEXP '^[0-9]{5}$' AND Postal NOT REGEXP '^[0-9]{5}-[0-9]{4}$';\n    COMMIT;\n\"\"\"\ninsert_proc(update_zip, 'update_zip', call=True)\n\nMySQL connection closed\nMySQL connection closed\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#isdeceased",
    "href": "01_SQL_Solution.html#isdeceased",
    "title": "SQL Solution",
    "section": "IsDeceased",
    "text": "IsDeceased\n\ncan only be TRUE or FALSE \n\nSource Table: - Contacts  \nSolution:  1. Create procedure to update Deceased to TRUE/FALSE\n\nupdate_deceased = f\"\"\"\n    UPDATE temp_contacts\n    SET Deceased = CASE\n        WHEN Deceased = 'Yes' THEN 1\n        ELSE 0\n    END;\n    commit;\n    ALTER TABLE temp_contacts MODIFY Deceased TINYINT;\n    commit;\n\"\"\"\ninsert_proc(update_deceased, 'update_deceased', call=True)\n\nMySQL connection closed\nMySQL connection closed\nError: 1292 (22007): Truncated incorrect DOUBLE value: 'Yes'\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#gifttype",
    "href": "01_SQL_Solution.html#gifttype",
    "title": "SQL Solution",
    "section": "GiftType",
    "text": "GiftType\n\nCan only be Cash, Check, Credit, Other, or Reversing Transaction \n\nSource Table: - Gifts  \nSolution: 1. Identify Incorrect Gift Types 2. Create procedure to replace invalid gift types\n\npd.read_sql('Select Distinct PaymentMethod from temp_gifts', engine)\n\n\n\n\n\n\n\n\nPaymentMethod\n\n\n\n\n0\nPayPal\n\n\n1\ncheck\n\n\n2\ncash\n\n\n3\ncredit card\n\n\n4\n\n\n\n5\nmoney order\n\n\n\n\n\n\n\nIt looks like there are several payment methods that don’t match the approved list. Additionally, the payment method ‘credit card’ will need to be mapped to ‘credit’\n\nupdate_gift_type = f\"\"\"\n  UPDATE temp_gifts\n  SET PaymentMethod = CASE\n    WHEN AmountReceived &lt; 0 THEN 'Reversing Transaction'\n    WHEN LOWER(TRIM(PaymentMethod)) = 'cash' THEN 'Cash'\n    WHEN LOWER(TRIM(PaymentMethod)) = 'check' THEN 'Check'\n    WHEN LOWER(TRIM(PaymentMethod)) LIKE 'credit%' THEN 'Credit'\n    ELSE 'Other'\n  END;\n  commit;\n\"\"\"\ninsert_proc(update_gift_type, 'update_gift_type', call=True)\n\nMySQL connection closed\nMySQL connection closed\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#creditcardtype",
    "href": "01_SQL_Solution.html#creditcardtype",
    "title": "SQL Solution",
    "section": "CreditCardType",
    "text": "CreditCardType\n\nCan only be Visa, Mastercard, AMEX, Discover  \n\nSolution:  1. Identify Incorrect Credit Types  2. Create procedure to replace invalid credit types\n\npd.read_sql('select distinct CreditCardType from temp_gifts', engine)\n\n\n\n\n\n\n\n\nCreditCardType\n\n\n\n\n0\n\n\n\n1\nAmerican Ex\n\n\n2\nAMEX\n\n\n3\nVisa\n\n\n4\nMaster card\n\n\n5\nMastercard\n\n\n6\nDiscover\n\n\n\n\n\n\n\n\nproc = f\"\"\"\nUPDATE temp_gifts\n    SET CreditCardType = CASE\n    WHEN CreditCardType  = 'Master card' THEN 'Mastercard'\n    else 'AMEX'\n    end\nWHERE CreditCardType IN ('American Ex', 'Master car');\ncommit;\n\"\"\"\ninsert_proc(proc, 'update_gift_type', call=True)\n\nMySQL connection closed\nMySQL connection closed\nMySQL connection closed"
  },
  {
    "objectID": "01_SQL_Solution.html#contacts",
    "href": "01_SQL_Solution.html#contacts",
    "title": "SQL Solution",
    "section": "Contacts",
    "text": "Contacts\n\nCreating the final contacts table  \n\n\nThe cleaning is done \nCreating contacts table and renaming various columns \n\nCreating procedure, selecting 5 rows from the contacts table\n\n\nCode\nproc = \"\"\"\n\n\nCREATE TABLE IF NOT EXISTS contacts (\n    `LegacyContactId` VARCHAR(255),\n    `LegacyIndividualId` VARCHAR(255),\n    `ContactType` VARCHAR(255),\n    `ContactName` VARCHAR(255),\n    `FirstName` VARCHAR(255),\n    `LastName` VARCHAR(255),\n    `SecondaryLegacyIndividualId` VARCHAR(255),\n    `SecondaryFirstName` VARCHAR(255),\n    `SecondaryLastName` VARCHAR(255),\n    `HomePhone` VARCHAR(255),\n    `HomeEmail` VARCHAR(255),\n    `Address1` VARCHAR(255),\n    `City` VARCHAR(255),\n    `State` VARCHAR(255),\n    `PostalCode` VARCHAR(255),\n    `IsPrivate` VARCHAR(255),\n    `IsDeceased` VARCHAR(255)\n);\ninsert into contacts\nSELECT \n    `Number` AS `LegacyContactId`,\n    `LegacyIndividualId`,\n    `ContactType`,\n    `ContactName`,\n    `FirstName`,\n    `LastName`,\n    `SecondaryLegacyIndividualId`,\n    `SecondaryFirstName`,\n    `SecondaryLastName`,\n    CASE WHEN\n        temp_contact_methods.`Phone`  = '' \n        THEN temp_contacts.`Phone`\n        ELSE temp_contact_methods.`Phone`\n    END AS HomePhone,\n    CASE WHEN\n        temp_contact_methods.`EMail`  = ''\n        THEN temp_contacts.`EMail`\n        ELSE temp_contact_methods.`EMail`\n    END AS HomeEmail,\n    `Street` AS `Address1`,\n    `City`,\n    `State`,\n    `Postal` AS `PostalCode`,\n    `Private` AS `IsPrivate`,\n    `Deceased` AS `IsDeceased`\nFROM \ntemp_contacts\nLEFT JOIN\n    temp_contact_methods ON temp_contact_methods.DonorNumber = temp_contacts.`Number`;\n    \ncommit;\n\"\"\"\ninsert_proc(proc, 'create_contacts', call=True, hide_output=True)\npd.read_sql('select * from contacts limit 5', engine)\n\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyIndividualId\nContactType\nContactName\nFirstName\nLastName\nSecondaryLegacyIndividualId\nSecondaryFirstName\nSecondaryLastName\nHomePhone\nHomeEmail\nAddress1\nCity\nState\nPostalCode\nIsPrivate\nIsDeceased\n\n\n\n\n0\n653377813-7\n0\nHousehold\nKarita & Kelvin Lumbers\nKarita\nLumbers\n1\nKelvin\nLumbers\n832-442-4988\nkklumbers@yahoo.com\n4 Bunting Parkway\nWashington\nDC\n\n1\n0\n\n\n1\n390551098-7\n2\nHousehold\nHelga Benech\nHelga\nBenech\n\n\n\n\nebenech1@goodreads.com\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n0\n0\n\n\n2\n093004505-X\n3\nHousehold\nMasha Butt Gow\nMasha\nButt Gow\n\n\n\n818-323-9865\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n0\n0\n\n\n3\n729707142-0\n4\nOrganization\nCymbre Cross\nCymbre\nCross\n\n\n\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n\n0\n0\n\n\n4\n488464926-5\n5\nHousehold\nHoyt Castille\nHoyt\nCastille\n\n\n\n\nfcastille4@timesonline.co.uk\n37 8th Trail\nGrand Rapids\nMI\n49560\n0\n0"
  },
  {
    "objectID": "01_SQL_Solution.html#gifts",
    "href": "01_SQL_Solution.html#gifts",
    "title": "SQL Solution",
    "section": "Gifts",
    "text": "Gifts\n\nCreating the final gifts column \n\n\nThe cleaning is done \nCreating the gifts table and renaming some columns \n\n\n\nCode\nproc = \"\"\"\nCREATE TABLE IF NOT EXISTS gifts (\n    LegacyContactId VARCHAR(255),\n    LegacyGiftId INTEGER,\n    GiftType TEXT,\n    GiftDate TEXT,\n    GiftAmount REAL,\n    Notes TEXT,\n    CreditCardType TEXT,\n    Project1Code TEXT,\n    Project2Code TEXT,\n    LegacyPledgeID INTEGER\n);\n\ninsert into gifts\nselect \n    DonorNumber as LegacyContactId,\n    LegacyGiftId,\n    PaymentMethod as GiftType,\n    GiftDate,\n    AmountReceived as GiftAmount,\n    Notes,\n    CreditCardType,\n    Project1Code,\n    Project2Code,\n    LegacyPledgeID\nfrom temp_gifts;\n\ncommit;\n\"\"\"\ninsert_proc(proc, 'create_gifts', call=True, hide_output=True)\npd.read_sql('select * from gifts limit 5', engine)\n\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyGiftId\nGiftType\nGiftDate\nGiftAmount\nNotes\nCreditCardType\nProject1Code\nProject2Code\nLegacyPledgeID\n\n\n\n\n0\n848348568-0\n95196378\nOther\n2019-03-04 00:00:00\n4.1500\n\n\n\nNone\n0\n\n\n1\n729707142-0\n95196889\nCheck\n2019-03-05 00:00:00\n2.3648\n\n\nChildSponsorship\nNone\n1\n\n\n2\n687119652-8\n95197689\nCash\n2019-03-07 00:00:00\n1.3100\n\n\n\nNone\n2\n\n\n3\n653377813-7\n95198998\nCredit\n2019-03-10 00:00:00\n2.0400\nIn honor of Mannie Turpin\nAMEX\n\nNone\n3\n\n\n4\n390551098-7\n95198999\nCash\n2019-01-10 00:00:00\n5.8000\n\n\n\nNone\n89752384"
  },
  {
    "objectID": "01_SQL_Solution.html#contact-methods",
    "href": "01_SQL_Solution.html#contact-methods",
    "title": "SQL Solution",
    "section": "Contact Methods",
    "text": "Contact Methods\n Procedure to create contact_methods table  \n\nCreating a contact_methods \nInserting distinct values from the contacts table \n\n\n\nCode\nproc = \"\"\"\nCREATE TABLE IF NOT EXISTS contact_methods (\n    `LegacyContactId` VARCHAR(255),\n    `Type` VARCHAR(255),\n    `Value` VARCHAR(255)\n);\n\nBEGIN\nDECLARE done INT DEFAULT FALSE;\nDECLARE v_LegacyContactId VARCHAR(255);\nDECLARE v_HomePhone VARCHAR(255);\nDECLARE v_HomeEmail VARCHAR(255);\nDECLARE v_Fax VARCHAR(255);\nDECLARE cur CURSOR FOR \n    SELECT DISTINCT\n        contacts.`LegacyContactId` AS LegacyContactId,\n        contacts.`HomePhone` AS HomePhone,\n        contacts.`HomeEmail` AS HomeEmail,\n        temp_contact_methods.Fax AS fax\n    FROM \n        contacts\n    JOIN\n        temp_contact_methods ON temp_contact_methods.DonorNumber = contacts.`LegacyContactId`;\n\nDECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;\n\n    OPEN cur;\n\n    read_loop: LOOP\n        FETCH cur INTO v_LegacyContactId, v_HomePhone, v_HomeEmail,v_Fax;\n        \n        IF done THEN\n            LEAVE read_loop;\n        END IF;\n\n        INSERT INTO contact_methods (`LegacyContactId`, `Type`, `Value`) VALUES \n            (v_LegacyContactId, 'HomePhone', v_HomePhone),\n            (v_LegacyContactId, 'HomeEmail', v_HomeEmail),\n            (v_LegacyContactId, 'Fax', v_Fax);\n    END LOOP;\n\n    CLOSE cur;\nEND;\n\n-- Delete records from contact methods where value is null or ''\nDELETE FROM contact_methods WHERE `Value` IS NULL OR `Value` = '';\n\n\ncommit;\n\n\n\"\"\"\ninsert_proc(proc, 'transform_contact_methods', call=True, hide_output=True)\npd.read_sql('select * from contact_methods order by LegacyContactId', con=engine)\n\n\n\n\n\n\n\n\n\nLegacyContactId\nType\nValue\n\n\n\n\n0\n029456846-8\nHomeEmail\njdoley6@telegraph.co.uk\n\n\n1\n093004505-X\nHomePhone\n818-323-9865\n\n\n2\n093004505-X\nFax\n818-156-7985\n\n\n3\n315297729-8\nHomeEmail\ndmouncey9@cnn.com\n\n\n4\n390551098-7\nHomeEmail\nebenech1@goodreads.com\n\n\n5\n488464926-5\nHomeEmail\nfcastille4@timesonline.co.uk\n\n\n6\n653377813-7\nHomePhone\n832-442-4988\n\n\n7\n653377813-7\nHomeEmail\nkklumbers@yahoo.com\n\n\n8\n687119652-8\nHomeEmail\ncmakepeace7@1688.com\n\n\n9\n739131380-7\nFax\n626-981-3874\n\n\n10\n848348568-0\nHomePhone\n702-844-9524"
  },
  {
    "objectID": "00_Setup.html",
    "href": "00_Setup.html",
    "title": "Setup",
    "section": "",
    "text": "Loading Datasets using Pandas\n\n\ncontacts.head()\n\n\n\n\n\n\n\n\nNumber\nCompany Name\nFirst Name\nLast Name\nStreet\nCity\nState\nPostal\nPhone\nE-mail\nRemarks\nDeceased?\n\n\n\n\n0\n653377813-7\n\nKarita & Kelvin\nLumbers\n4 Bunting Parkway\nWashington\nDC\n20535-871\nkklumbers@ yahoo.co\n\nIs anonymous\n\n\n\n1\n390551098-7\n\nHelga\nBenech\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n\nebenech1@goodreads.com\n\n\n\n\n2\n093004505-X\n\nMasha\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n\n577-374-96523\n\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n8104\n\n\n\nNo\n\n\n4\n488464926-5\n\nHoyt\nCastille\n37 8th Trail\nGrand Rapids\nMI\n49560\n\nfcastille4@timesonline.co.uk\n\nNo\n\n\n\n\n\n\n\n\ngifts.head()\n\n\n\n\n\n\n\n\ndonor_number\ngift_id\nfirst_name\nlast_name\namount received\ndate\nfund_id\ncredit card type\npayment method\npledge_number\nnotes\n\n\n\n\n0\n848348568-0\n95196378.0\nMannie\nTurpin\n$4.15\n3/4/2019\n\n\nPayPal\n\n\n\n\n1\n729707142-0\n95196889.0\nCymbre\nCross\n2.3648\n3/5/2019\nChildSponsorship\n\ncheck\n\n\n\n\n2\n687119652-8\n95197689.0\nRuggiero\nMakepeace\n$1.31\n3/7/2019\n\n\ncash\n\n\n\n\n3\n653377813-7\n95198998.0\nKarita\nLumbers\n$2.04\n3/10/2019\n\nAmerican Ex\ncredit card\n\nIn honor of Mannie Turpin\n\n\n4\n390551098-7\n95198999.0\nHelga\nBenech\n$5.80\n2019/1/10\n\n\ncash\n89752384.0\n\n\n\n\n\n\n\n\n\ncontact_methods.head()\n\n\n\n\n\n\n\n\ndonor_number\nPhone\nE-mail\nFax\n\n\n\n\n0\n653377813-7\n832-442-4988\n\n\n\n\n1\n390551098-7\n\nebenech1@goodreads.com\n\n\n\n2\n093004505-X\n818-323-9865\n\n818-156-7985\n\n\n3\n729707142-0\n\n\n\n\n\n4\n488464926-5\n\nfcastille4@timesonline.co.uk"
  },
  {
    "objectID": "00_Setup.html#column-name-transformation",
    "href": "00_Setup.html#column-name-transformation",
    "title": "Setup",
    "section": "Column Name Transformation",
    "text": "Column Name Transformation\n\n\nNothing worse than malformed column names, amiright?  \n\n\nsource\n\nto_camel_case\n\n to_camel_case (s)\n\nConverts a string to camel case.\n\n\nExamples\nstripping spaces\n\nto_camel_case('this isa test')\n\n'ThisIsaTest'\n\n\nStripping Special Characters\n\nto_camel_case('this_is_a_test')\n\n'ThisIsATest'\n\n\n\nto_camel_case('hello!world_what_is_up?')\n\n'HelloWorldWhatIsUp'\n\n\n\nsource\n\n\ntransform_cnames\n\n transform_cnames (df, func=&lt;function to_camel_case&gt;)\n\nApply a function to all column names of a dataframe. It may not always be the case that I want to apply to_camel_case as the column transformation function. Because of this func is an optional argument with a default value of to_camel_case\nApply a function to all column names of a dataframe\n\nfor df in [contact_methods, contacts, gifts]:\n    transform_cnames(df)\n\nValidating that the contacts column names are now CamelCase\n\ncontacts.columns\n\nIndex(['Number', 'CompanyName', 'FirstName', 'LastName', 'Street', 'City',\n       'State', 'Postal', 'Phone', 'EMail', 'Remarks', 'Deceased'],\n      dtype='object')"
  },
  {
    "objectID": "00_Setup.html#column-type-transformation",
    "href": "00_Setup.html#column-type-transformation",
    "title": "Setup",
    "section": "Column Type Transformation",
    "text": "Column Type Transformation\nI identified 2 columns on the gift table that should be ints \nI’m going to convert them both to type int\n\nint_cols = ['GiftId', 'PledgeNumber']\n\n\ngifts[int_cols] = gifts[int_cols].replace({'':0}).astype(int)\n\nAmountRecieved should be a float \nRemoving any special characters (besides dashes and periods) and converting to a float :)\n\ngifts['AmountReceived'] = gifts.AmountReceived.apply(lambda x: float(re.sub(r'[^a-zA-Z0-9\\.-]', '', x)))\n\nPreviewing change\n\ngifts.AmountReceived.head(5)\n\n0    4.1500\n1    2.3648\n2    1.3100\n3    2.0400\n4    5.8000\nName: AmountReceived, dtype: float64\n\n\nReplacing ‘0’ values in PledgeNumber & GiftId to thier index so that each row is unique\n\ngifts.loc[ gifts.PledgeNumber == 0, 'PledgeNumber'] = gifts[gifts.PledgeNumber == 0].index\ngifts.loc[ gifts.GiftId == 0, 'GiftId'] = gifts[gifts.GiftId == 0].index\n\n\ngifts[['PledgeNumber', 'GiftId']].head(5)\n\n\n\n\n\n\n\n\nPledgeNumber\nGiftId\n\n\n\n\n0\n0\n95196378\n\n\n1\n1\n95196889\n\n\n2\n2\n95197689\n\n\n3\n3\n95198998\n\n\n4\n89752384\n95198999\n\n\n\n\n\n\n\nRenaming the columns to match virtuous requirements\n\ngifts = gifts.rename(columns={'PledgeNumber': 'LegacyPledgeID', 'GiftId': 'LegacyGiftId'})"
  },
  {
    "objectID": "00_Setup.html#misplaced-data-transformation",
    "href": "00_Setup.html#misplaced-data-transformation",
    "title": "Setup",
    "section": "Misplaced Data Transformation",
    "text": "Misplaced Data Transformation\n\nIdentify and clean any pieces of data in the wrong column\n\n\ncontacts[['Phone', 'EMail']].head(3)\n\n\n\n\n\n\n\n\nPhone\nEMail\n\n\n\n\n0\nkklumbers@ yahoo.co\n\n\n\n1\n\nebenech1@goodreads.com\n\n\n2\n\n577-374-96523\n\n\n\n\n\n\n\nCreating a function that uses regular expressions to identify a string as a phone or a email\n\nsource\n\nclassify_phone_email\n\n classify_phone_email (value)\n\nClassify a value as a phone number, email, or None.\n\n\nExamples\n\nclassify_phone_email('321-295-2502')\n\n'phone'\n\n\n\nclassify_phone_email('warren.hyson5@gmail.com')\n\n'email'\n\n\n\nclassify_phone_email('test321-29@gmail.com')\n\n'email'\n\n\n\nclassify_phone_email('3212952502@gmail.com')\n\n'email'\n\n\n\nclassify_phone_email('321-295-2502@gmail.com')\n\n'email'\n\n\n\n\nApplying Phone/Email Transformation\nLooping over phone & email records.  If a phone and/or email are identified in the wrong column, I’m swapping thier values\n\ncontacts[['Phone', 'EMail']].head(3)\n\n\n\n\n\n\n\n\nPhone\nEMail\n\n\n\n\n0\n\nkklumbers@ yahoo.co\n\n\n1\n\nebenech1@goodreads.com\n\n\n2\n577-374-96523"
  },
  {
    "objectID": "00_Setup.html#consolidate-contacts-table",
    "href": "00_Setup.html#consolidate-contacts-table",
    "title": "Setup",
    "section": "Consolidate Contacts Table",
    "text": "Consolidate Contacts Table\n\nSearching for missing users \nSplitting / joining households \n\n\nChecking for Missing records\nChecking for any DonorNumbers that are NOT IN contacts Number…\n\n(~gifts.DonorNumber.isin(contacts.Number.unique())).any()\n\nTrue\n\n\nFound 1!   Doing the same for contact_methods\n\n(~contact_methods.DonorNumber.isin(contacts.Number.unique())).any()\n\nFalse\n\n\nDidn’t find any there  Going to extract the missing records from the gifts table\n\ndonors_not_in_contacts = gifts.loc[~gifts.DonorNumber.isin(contacts.Number.unique()), :]\n\n\ndonors_not_in_contacts\n\n\n\n\n\n\n\n\nDonorNumber\nLegacyGiftId\nFirstName\nLastName\nAmountReceived\nDate\nFundId\nCreditCardType\nPaymentMethod\nLegacyPledgeID\nNotes\n\n\n\n\n9\n809975531-Y\n9\nAdeline\nShakespeare\n8.48\n8/14/2019\n\nAMEX\ncredit card\n9\n\n\n\n27\n809975531-Y\n27\nAdeline\nShakespeare\n7.58\n8/14/2019\nColor run, ChildSponsorship\nMastercard\ncredit card\n27\n\n\n\n\n\n\n\n\nAdding Shakespeare to our contacts!\n\ncontacts = pd.concat([\n    contacts,\n    # Dataframe of donors not in contacts\n    pd.DataFrame(donors_not_in_contacts[['DonorNumber', 'FirstName', 'LastName']]\n                 .drop_duplicates()\n                 .rename(columns={'DonorNumber': 'Number'})\n                 .drop_duplicates()\n                 .to_dict('records'))\n])\n\n\n\nSpliting rows with Multiple People\n\ncontacts.FirstName.head(1)\n\n0    Karita & Kelvin\nName: FirstName, dtype: object\n\n\nSplit the names on ’ & ’ or ’ and ’, then expand the resulting lists into new rows\n\ncontacts[['FirstName', 'SecondaryFirstName']] = contacts['FirstName'].str.split(' & | and ', expand=True).fillna('')\n\nAditionally, going to look for any records where there’s a duplicated Number \nThe following Python code will return True for rows where the Number was deemed to be a duplicate:\ncontacts.Number.duplicated()\nFor all the rows that are duplicates, I’m going to: 1. Place them in a seperate variable  2. Remove them from the original dataset  3. Add them as the 2nd Person on the non-duplicated row  4. Ensure they have proper first & last names\n\nrecords_to_join = contacts.loc[contacts.Number.duplicated(), :].to_dict(orient='records')\n\nRemoving duplicates from contacts before joining\n\ncontacts = contacts.loc[~contacts.Number.duplicated(), :]\n\nAdding dupliates as secondary contacts\n\nfor record in records_to_join:\n    contacts.loc[contacts.Number.isin([record['Number']]), ['SecondaryFirstName', 'SecondaryLastName']] = [record['FirstName'], record['LastName']]\n\nAdding Secondary Last Name where it was previously missing\n\ncontacts['SecondaryLastName'] = contacts.apply(lambda x: x['LastName'] if x['SecondaryLastName'] == '' and x['SecondaryFirstName'] != '' else x['SecondaryLastName'], axis=1)\n\n\n\nUpdating unique identifiers\n\nEnsuring LegacyIndividualId is present for all contacts & is unique\n\nInitalizing empty collumns\nAdding id since none was provided\n\nid = 0\nfor index, row in contacts.iterrows():\n    contacts.loc[index, 'LegacyIndividualId'] = id\n    id += 1\n    if row['SecondaryFirstName'] != '':\n        contacts.loc[index, 'SecondaryLegacyIndividualId'] = id\n        id += 1"
  },
  {
    "objectID": "00_Setup.html#cleaning-contact-first-last-names",
    "href": "00_Setup.html#cleaning-contact-first-last-names",
    "title": "Setup",
    "section": "Cleaning Contact First & Last Names",
    "text": "Cleaning Contact First & Last Names\n\nCleaning Records with blank first or last names \n\nChecking for records where FirstName and/or LastName is blank\n\nblank_name_records = ((contacts.FirstName == '') | (contacts.LastName == ''))\n\nPreviewing the blank name records\n\ncontacts.loc[((contacts.FirstName == '') | (contacts.LastName == '')), :]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\n\n\n\n\n2\n093004505-X\n\nMasha\n\n353 Schmedeman Park\nIndianapolis\nIN\n\n577-374-96523\n\n\n\n\n\n3\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n8104\n\n\n\nNo\n\n\n4\n\n\n\n7\n029456846-8\n\n\n\n608 Old Shore Alley\nMarietta\nGA\n30066\n\njdoley6@telegraph.co.uk\n\n\n\n\n9\n\n\n\n\n\n\n\n\nBefore I delete the records I’m going to check if the names are present on the gift table   I’m going to start by getting the unique Numbers that the records belong too\n\nblank_name_numbers= contacts.loc[blank_name_records, 'Number']\n\n\ngifts.loc[gifts.DonorNumber.isin(blank_name_numbers), ['DonorNumber', 'FirstName', 'LastName']].drop_duplicates().head(5)\n\n\n\n\n\n\n\n\nDonorNumber\nFirstName\nLastName\n\n\n\n\n1\n729707142-0\nCymbre\nCross\n\n\n6\n029456846-8\nRomy\nDoley\n\n\n7\n093004505-X\nMasha\nButt Gow\n\n\n19\n729707142-0\nCymbre\n\n\n\n\n\n\n\n\nThe names are present on the gifts table!\n\ngift_name_records = gifts.loc[gifts.DonorNumber.isin(blank_name_numbers), ['DonorNumber', 'FirstName', 'LastName']].drop_duplicates()\n\nRemoving the invalid record\n\ngift_name_records = gift_name_records.loc[((gift_name_records.FirstName != '') & (gift_name_records.LastName != '')), :]\ngift_name_records\n\n\n\n\n\n\n\n\nDonorNumber\nFirstName\nLastName\n\n\n\n\n1\n729707142-0\nCymbre\nCross\n\n\n6\n029456846-8\nRomy\nDoley\n\n\n7\n093004505-X\nMasha\nButt Gow\n\n\n\n\n\n\n\nUpdating the records that previousuly had a blank first or last name\n\nfor _, row in gift_name_records.iterrows():\n    contacts.loc[contacts['Number'] == row['DonorNumber'], ['FirstName', 'LastName']] = [row['FirstName'], row['LastName']]\n\nAll the records valid names now!\n\ncontacts.loc[blank_name_records, :]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\n\n\n\n\n2\n093004505-X\n\nMasha\nButt Gow\n353 Schmedeman Park\nIndianapolis\nIN\n\n577-374-96523\n\n\n\n\n\n3\n\n\n\n3\n729707142-0\nA Company Co.\nCymbre\nCross\n2055 Lakewood Parkway\nCamden\nNJ\n8104\n\n\n\nNo\n\n\n4\n\n\n\n7\n029456846-8\n\nRomy\nDoley\n608 Old Shore Alley\nMarietta\nGA\n30066\n\njdoley6@telegraph.co.uk\n\n\n\n\n9"
  },
  {
    "objectID": "00_Setup.html#add-contactname-column",
    "href": "00_Setup.html#add-contactname-column",
    "title": "Setup",
    "section": "Add ContactName Column",
    "text": "Add ContactName Column\n\ncontacts.head(3)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nFirstName\nLastName\nStreet\nCity\nState\nPostal\nPhone\nEMail\nRemarks\nDeceased\nSecondaryFirstName\nSecondaryLastName\nLegacyIndividualId\nSecondaryLegacyIndividualId\n\n\n\n\n0\n653377813-7\n\nKarita\nLumbers\n4 Bunting Parkway\nWashington\nDC\n20535-871\n\nkklumbers@ yahoo.co\nIs anonymous\n\nKelvin\nLumbers\n0\n1\n\n\n1\n390551098-7\n\nHelga\nBenech\n48684 Jenifer Way\nLas Vegas\nNV\n89130\n\nebenech1@goodreads.com\n\n\n\n\n2\n\n\n\n2\n093004505-X\n\nMasha\nButt Gow\n353 Schmedeman Park\nIndianapolis\nIN\n\n577-374-96523\n\n\n\n\n\n3\n\n\n\n\n\n\n\n\nCreating a function to update the contact name depending on the individuals on the household record\n\ndef set_contact_name(row):\n    \"\"\"Sets the contact name for a given row in the dataframe.\"\"\"\n    if row['LastName'] == row['SecondaryLastName']:\n        return row['FirstName'] + ' & ' + row['SecondaryFirstName'] + ' ' + row['LastName']\n    elif row['SecondaryFirstName'] != '':\n        return row['FirstName'] +  ' ' + row['LastName'] + ' & ' + row['SecondaryFirstName'] + ' ' + row['SecondaryLastName']\n    else:\n        return row['FirstName'] + ' ' + row['LastName']\n\n\nsource\n\nset_contact_name\n\n set_contact_name (row)\n\nSets the contact name for a given row in the dataframe.\n\ncontacts['ContactName'] = contacts.apply(set_contact_name, axis=1)\n\nPreviewing result\n\ncontacts[['ContactName', 'FirstName', 'LastName', 'SecondaryFirstName', 'SecondaryLastName']].head(5)\n\n\n\n\n\n\n\n\nContactName\nFirstName\nLastName\nSecondaryFirstName\nSecondaryLastName\n\n\n\n\n0\nKarita & Kelvin Lumbers\nKarita\nLumbers\nKelvin\nLumbers\n\n\n1\nHelga Benech\nHelga\nBenech\n\n\n\n\n2\nMasha Butt Gow\nMasha\nButt Gow\n\n\n\n\n3\nCymbre Cross\nCymbre\nCross\n\n\n\n\n4\nHoyt Castille\nHoyt\nCastille"
  },
  {
    "objectID": "00_Setup.html#projectcode-transformation",
    "href": "00_Setup.html#projectcode-transformation",
    "title": "Setup",
    "section": "ProjectCode Transformation",
    "text": "ProjectCode Transformation\n\nSplitting FundId\n\nSplitting the FundId column by ','\n\nproject_codes = gifts.FundId.str.split(', ', expand=True)\n\n\nproject_codes.head(6)\n\n\n\n\n\n\n\n\n0\n1\n\n\n\n\n0\n\nNone\n\n\n1\nChildSponsorship\nNone\n\n\n2\n\nNone\n\n\n3\n\nNone\n\n\n4\n\nNone\n\n\n5\nGeneral\nReliefFund\n\n\n\n\n\n\n\nAssigning the values to the Project1 & 2 columns\n\ngifts[['Project1Code', 'Project2Code']] = project_codes\n\nRemoving FundId from the dataset\n\ngifts = gifts.loc[:, gifts.columns.drop('FundId')].copy()"
  },
  {
    "objectID": "00_Setup.html#date-transformation",
    "href": "00_Setup.html#date-transformation",
    "title": "Setup",
    "section": "Date Transformation",
    "text": "Date Transformation\n\nFormating date\n\n\ndf['Date'].head(5)\n\n0     3/4/2019\n1     3/5/2019\n2     3/7/2019\n3    3/10/2019\n4    2019/1/10\nName: Date, dtype: object\n\n\nSince Dates are in different formats I’m going to create a custom parser\n\nsource\n\ncustom_parser\n\n custom_parser (date_str)\n\nParses a date string into a datetime object.\n\n\nExamples\n\ncustom_parser('4/14/1999')\n\ndatetime.datetime(1999, 4, 14, 0, 0)\n\n\n\ncustom_parser('1999/04/14')\n\ndatetime.datetime(1999, 4, 14, 0, 0)\n\n\n\n\nTransforming Dates\n\ngifts['GiftDate'] = gifts['Date'].apply(custom_parser)\n\nDropping old date columns\n\ngifts = gifts.loc[:, gifts.columns.drop('Date')].copy()"
  },
  {
    "objectID": "00_Setup.html#email-transformation",
    "href": "00_Setup.html#email-transformation",
    "title": "Setup",
    "section": "Email Transformation",
    "text": "Email Transformation\n\nValidate emails\n\nPreviewing the Email column\n\ncontacts.EMail.head(1)\n\n0    kklumbers@ yahoo.co\nName: EMail, dtype: object\n\n\nIt looks like the first email ‘kklumbers@ yahoo.co’ is invalid and should be fixed   I’m going to write a function to validate emails and fix common mistakes\n\nsource\n\nvalid_email\n\n valid_email (s)\n\nValidates an email address.\n\n\nExamples\n\nvalid_email('warren.hyson5@gmail.com')\n\nTrue\n\n\n\nvalid_email('warren.hyson5@gmail')\n\nFalse\n\n\n\nvalid_email('warren.hyson5@.com')\n\nFalse\n\n\n\nvalid_email('warren.hyson5@gmailcom')\n\nFalse\n\n\n\nvalid_email('warren.hyson5@@gmail.com')\n\nFalse\n\n\n Creating a second function that attempts to fix common email mistakes like mispelled domains\n\nsource\n\n\nfix_email\n\n fix_email (email)\n\nFixes common mistakes in email addresses.\n\n\nExamples\ncorrect\n\nfix_email('warren.hyson5@gmail.com')\n\n'warren.hyson5@gmail.com'\n\n\ngmail spelled wrong\n\nfix_email('warren.hyson5@gmial.com')\n\n'warren.hyson5@gmail.com'\n\n\ncom spelled wrong\n\nfix_email('warren.hyson5@gmial.con')\n\n'warren.hyson5@gmail.com'\n\n\n\n\nApplying Email Transformation\nPreviewing\n\ncontacts.EMail.head(1).apply(fix_email)\n\n0    kklumbers@yahoo.com\nName: EMail, dtype: object\n\n\n\ncontacts['EMail'] = contacts.EMail.apply(fix_email)"
  },
  {
    "objectID": "00_Setup.html#phone-transformation",
    "href": "00_Setup.html#phone-transformation",
    "title": "Setup",
    "section": "Phone # Transformation",
    "text": "Phone # Transformation\n\nFix phone numbers\n\nThere appears to be a invalid phone number\n\ncontacts.loc[2, 'Phone']\n\n'577-374-96523'\n\n\nWriting a function to validate US phone numbers, assuming the phone numbers provided are from the US\n\nsource\n\nvalidate_us_phone_number\n\n validate_us_phone_number (phone_number)\n\nValidates a US phone number and returns it if valid, otherwise returns an empty string.\n\n\nExamples\n\nvalidate_us_phone_number('321-295-2502')\n\n'321-295-2502'\n\n\nno-dashes 10 digit\n\nvalidate_us_phone_number('3212952502')\n\n'3212952502'\n\n\nno-dashes 7 digit\n\nvalidate_us_phone_number('2952502')\n\n'2952502'\n\n\nno-dashes 11 digit\n\nvalidate_us_phone_number('13212952502')\n\n''\n\n\nWith Parenthesese\n\nvalidate_us_phone_number(\"(123) 456-7890\")\n\n'(123) 456-7890'\n\n\nRandom Text\n\nvalidate_us_phone_number('407-555-1234 ext. 1234')\n\n''\n\n\n\n\nApplying Phone # Transformation\n\ncontacts['Phone'] = contacts.Phone.apply(validate_us_phone_number)\n\n\ncontacts.fillna('', inplace=True)"
  },
  {
    "objectID": "04_Test.html",
    "href": "04_Test.html",
    "title": "Validation",
    "section": "",
    "text": "final_contacts = pd.read_csv('data/final_contacts.csv').fillna('')\nfinal_contact_methods = pd.read_csv('data/final_contact_methods.csv').fillna('')\nfinal_gifts = pd.read_csv('data/final_gifts.csv').fillna('')"
  },
  {
    "objectID": "04_Test.html#validating-required-fields-are-not-missing",
    "href": "04_Test.html#validating-required-fields-are-not-missing",
    "title": "Validation",
    "section": "Validating Required Fields Are Not Missing",
    "text": "Validating Required Fields Are Not Missing\n\nsource\n\ntest_contact_required_fields\n\n test_contact_required_fields ()\n\nValidate that all required fields are present in the final_contacts dataframe.\n\n\ntest_contact_required_fields()"
  },
  {
    "objectID": "04_Test.html#validating-contacttype",
    "href": "04_Test.html#validating-contacttype",
    "title": "Validation",
    "section": "Validating ContactType",
    "text": "Validating ContactType\n\nsource\n\ntest_contacts_contact_type\n\n test_contacts_contact_type ()\n\nValidates that the ContactType column only contains the values ‘Household’ and ‘Organization’\n\n\ntest_contacts_contact_type()"
  },
  {
    "objectID": "04_Test.html#validating-email",
    "href": "04_Test.html#validating-email",
    "title": "Validation",
    "section": "Validating Email",
    "text": "Validating Email\n\nsource\n\ntest_contact_email\n\n test_contact_email ()\n\nValidates that all emails are valid\n\n\ntest_contact_email()"
  },
  {
    "objectID": "04_Test.html#validating-phone-number",
    "href": "04_Test.html#validating-phone-number",
    "title": "Validation",
    "section": "Validating Phone Number",
    "text": "Validating Phone Number\n\nsource\n\ntest_contact_phone_number_valid\n\n test_contact_phone_number_valid ()\n\nValidate that all phone numbers are valid\n\n\ntest_contact_phone_number_valid()"
  },
  {
    "objectID": "04_Test.html#validating-postal",
    "href": "04_Test.html#validating-postal",
    "title": "Validation",
    "section": "Validating Postal",
    "text": "Validating Postal\n\nsource\n\ntest_contact_valid_zip\n\n test_contact_valid_zip ()\n\nValidates that all contacts have a valid zip code\n\n\ntest_contact_valid_zip()"
  },
  {
    "objectID": "04_Test.html#validating-deceased",
    "href": "04_Test.html#validating-deceased",
    "title": "Validation",
    "section": "Validating Deceased",
    "text": "Validating Deceased\n\nsource\n\ntest_contact_deceased\n\n test_contact_deceased ()\n\nValidate that all contacts are either deceased or not deceased.\n\n\ntest_contact_deceased()"
  },
  {
    "objectID": "04_Test.html#validating-required-fields-are-not-missing-1",
    "href": "04_Test.html#validating-required-fields-are-not-missing-1",
    "title": "Validation",
    "section": "Validating Required Fields Are Not Missing",
    "text": "Validating Required Fields Are Not Missing\n\nsource\n\ntest_gift_required_fields\n\n test_gift_required_fields ()\n\nValidate that all required fields are present in the gift data.\n\n\ntest_gift_required_fields()"
  },
  {
    "objectID": "04_Test.html#validating-gifttype",
    "href": "04_Test.html#validating-gifttype",
    "title": "Validation",
    "section": "Validating GiftType",
    "text": "Validating GiftType\n\nsource\n\ntest_gift_type\n\n test_gift_type ()\n\nTest that all gift types are valid\n\n\ntest_gift_type()"
  },
  {
    "objectID": "04_Test.html#validating-giftamount",
    "href": "04_Test.html#validating-giftamount",
    "title": "Validation",
    "section": "Validating GiftAmount",
    "text": "Validating GiftAmount\n\nsource\n\ntest_gift_amount_is_float\n\n test_gift_amount_is_float ()\n\nTest that the GiftAmount column is a float\n\n\ntest_gift_amount_is_float()"
  },
  {
    "objectID": "04_Test.html#validating-creditcardtype",
    "href": "04_Test.html#validating-creditcardtype",
    "title": "Validation",
    "section": "Validating CreditCardType",
    "text": "Validating CreditCardType\n\nsource\n\ntest_credit_card_type\n\n test_credit_card_type ()\n\nTest that all credit card types are valid.\n\n\ntest_credit_card_type()"
  },
  {
    "objectID": "04_Test.html#validating-pledgeid",
    "href": "04_Test.html#validating-pledgeid",
    "title": "Validation",
    "section": "Validating PledgeId",
    "text": "Validating PledgeId\n\nsource\n\ntest_gift_pledge_id\n\n test_gift_pledge_id ()\n\nTest that the number of gifts is equal to the number of unique pledge IDs\n\n\ntest_gift_pledge_id()"
  },
  {
    "objectID": "04_Test.html#validating-required-fields-are-not-missing-2",
    "href": "04_Test.html#validating-required-fields-are-not-missing-2",
    "title": "Validation",
    "section": "Validating Required Fields Are Not Missing",
    "text": "Validating Required Fields Are Not Missing\n\nsource\n\ntest_contact_method_required_fields\n\n test_contact_method_required_fields ()\n\n\n\ntest_contact_method_required_fields()"
  },
  {
    "objectID": "04_Test.html#validating-type",
    "href": "04_Test.html#validating-type",
    "title": "Validation",
    "section": "Validating Type",
    "text": "Validating Type\n\nsource\n\ntest_contact_method_type\n\n test_contact_method_type ()\n\nTest that all contact methods are one of the three types\n\n\ntest_contact_method_type()"
  },
  {
    "objectID": "01_SQL_Cleanup.html",
    "href": "01_SQL_Cleanup.html",
    "title": "SQL Cleanup",
    "section": "",
    "text": "import mysql.connector\nfrom mysql.connector import Error\nfrom nbdev.showdoc import *\n\n\ntry:\n    connection = mysql.connector.connect(user='root', host='localhost')\n    cursor = connection.cursor()\n    cursor.execute(\"\"\"\n    USE exam_db;\n    DROP TABLE temp_contact_methods;\n    DROP TABLE temp_contacts;\n    DROP TABLE temp_gifts;\n    DROP TABLE contact_methods;\n    DROP TABLE contacts;\n    DROP TABLE gifts;\n    \"\"\")\nexcept Error as e:\n    print(f\"Error: {e}\")\nfinally:\n    if connection.is_connected():\n        cursor.close()\n        connection.close()"
  },
  {
    "objectID": "02_Pandas_Solution.html",
    "href": "02_Pandas_Solution.html",
    "title": "Python Solution",
    "section": "",
    "text": "Pandas :)\n\n\n\nDoes someone want to be private  \n\nSource Table: - Contacts Table  \nSolution:  1. Create procedure to add new column Private\nLooking for notes\n\ncontacts.Remarks[~contacts.Remarks.isin([''])]\n\n0                                 Is anonymous\n6    Met in person on 5/9/2018 at Annual Event\n8                      Electronic receipt only\nName: Remarks, dtype: object\n\n\n\ncontacts['Private'] = contacts.Remarks.apply(lambda x: True if x == 'Is anonymous' else False)\n\n\n\n\n\nis required and can only be Household or Organization  \n\nSource Table:  - Contacts Table  \nSolution: 1. Create procedure to add new column ContactType\n\ncontacts[['Number', 'CompanyName']]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\n\n\n\n\n0\n653377813-7\n\n\n\n1\n390551098-7\n\n\n\n2\n093004505-X\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n4\n488464926-5\n\n\n\n5\n315297729-8\n\n\n\n6\n848348568-0\n\n\n\n7\n029456846-8\n\n\n\n8\n687119652-8\n\n\n\n9\n739131380-7\n\n\n\n10\n809975531-Y\n\n\n\n\n\n\n\n\n\n\ncontacts['ContactType'] = contacts.apply(lambda x: 'Household' if x['CompanyName'] == '' else 'Organization', axis=1)\n\n\ncontacts[['Number', 'CompanyName', 'ContactType']].head(3)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nContactType\n\n\n\n\n0\n653377813-7\n\nHousehold\n\n\n1\n390551098-7\n\nHousehold\n\n\n2\n093004505-X\n\nHousehold\n\n\n\n\n\n\n\n\n\n\n\nif address is present and is US, must be a valid zip code, either 12345 or 12345-1234  \n\nSource Table: - Contacts  \nSolution:  1. Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\ncontacts['Postal'].head(3)\n\n0    20535-871\n1        89130\n2             \nName: Postal, dtype: object\n\n\n\npostal_code_pattern = '[0-9]{5}(?:-[0-9]{4})?$'\n\n\n\n\nbool(re.match(postal_code_pattern, '32828'))\n\nTrue\n\n\n\nbool(re.match(postal_code_pattern, '328289'))\n\nFalse\n\n\n\nbool(re.match(postal_code_pattern, '3282'))\n\nFalse\n\n\n\nbool(re.match(postal_code_pattern, '32828-237'))\n\nFalse\n\n\n\nbool(re.match(postal_code_pattern, '32828-2379'))\n\nTrue\n\n\n\n\n\n\ncontacts['Postal'] = contacts.Postal.apply(lambda x: x if re.match(postal_code_pattern, x) else '')\n\n\ncontacts['Postal'].head(3)\n\n0         \n1    89130\n2         \nName: Postal, dtype: object\n\n\n\n\n\n\n\ncan only be TRUE or FALSE  \n\nSource Table: - Contacts  \nSolution:  1. Create procedure to update Deceased to TRUE/FALSE\n\ncontacts.Deceased.head(3)\n\n0    \n1    \n2    \nName: Deceased, dtype: object\n\n\n\ncontacts['Deceased'] = contacts.Deceased.apply(lambda x: True if x == 'Yes' else False)\n\n\ncontacts.Deceased.head(3)\n\n0    False\n1    False\n2    False\nName: Deceased, dtype: bool\n\n\n\n\n\n\nCan only be Cash, Check, Credit, Other, or Reversing Transaction  \n\nSource Table: - Gifts  \nSolution:  1. Identify Incorrect Gift Types  2. Create procedure to replace invalid gift types \n\ngifts[['AmountReceived', 'PaymentMethod']].tail(10)\n\n\n\n\n\n\n\n\nAmountReceived\nPaymentMethod\n\n\n\n\n21\n4.21\ncredit card\n\n\n22\n9.28\ncash\n\n\n23\n2.74\nPayPal\n\n\n24\n9.00\nmoney order\n\n\n25\n1.88\ncash\n\n\n26\n-6.76\ncheck\n\n\n27\n7.58\ncredit card\n\n\n28\n5.49\ncash\n\n\n29\n8.93\nmoney order\n\n\n30\n2.62\ncredit card\n\n\n\n\n\n\n\n\ndef clean_payment_type(row):\n    payment_method = ''\n    orginal_payment_method = str(row['PaymentMethod']).lower()\n    \n    if row['AmountReceived'] &lt; 0:\n        payment_method = 'Reversing Transaction'\n    elif re.match('credit', orginal_payment_method):\n        payment_method = 'Credit'\n    elif orginal_payment_method in ['check', 'cash', 'reversing transaction']:\n        payment_method = orginal_payment_method.title()\n    else:\n        payment_method = 'Other'\n\n    return payment_method\n\n\nsource\n\n\n\n clean_payment_type (row)\n\n\n\n\n\n\ngifts['PaymentMethod'] = gifts.apply(clean_payment_type, axis=1)\n\n\ngifts.PaymentMethod.tail(10)\n\n21                   Credit\n22                     Cash\n23                    Other\n24                    Other\n25                     Cash\n26    Reversing Transaction\n27                   Credit\n28                     Cash\n29                    Other\n30                   Credit\nName: PaymentMethod, dtype: object\n\n\n\n\n\n\nCan only be Visa, Mastercard, AMEX, Discover   Solution:  1. Identify Incorrect Credit Types  2. Create procedure to replace invalid credit types\n\n\ngifts.CreditCardType.unique()\n\narray(['', 'American Ex', 'AMEX', 'Visa', 'Master card', 'Mastercard',\n       'Discover'], dtype=object)\n\n\nCreating functions to validate each of the credit card types\n\nsource\n\n\n\n validate_mastercard (string)\n\n\nsource\n\n\n\n\n validate_amex (string)\n\n\nsource\n\n\n\n\n validate_visa (string)\n\n\nsource\n\n\n\n\n validate_discover (string)\n\n\nsource\n\n\n\n\n validate_credit_card (string)\n\n\nvalidate_credit_card('Amex')\n\n'AMEX'\n\n\n\nvalidate_credit_card('Master Card')\n\n'Mastercard'\n\n\n\nvalidate_credit_card('visa')\n\n'Visa'\n\n\n\nvalidate_credit_card('test')\n\n''\n\n\n\nvalidate_credit_card('Gold card')\n\n''\n\n\n\n\n\n\n\ngifts['CreditCardType'] = gifts.CreditCardType.apply(validate_credit_card)"
  },
  {
    "objectID": "02_Pandas_Solution.html#private",
    "href": "02_Pandas_Solution.html#private",
    "title": "Python Solution",
    "section": "",
    "text": "Does someone want to be private  \n\nSource Table: - Contacts Table  \nSolution:  1. Create procedure to add new column Private\nLooking for notes\n\ncontacts.Remarks[~contacts.Remarks.isin([''])]\n\n0                                 Is anonymous\n6    Met in person on 5/9/2018 at Annual Event\n8                      Electronic receipt only\nName: Remarks, dtype: object\n\n\n\ncontacts['Private'] = contacts.Remarks.apply(lambda x: True if x == 'Is anonymous' else False)"
  },
  {
    "objectID": "02_Pandas_Solution.html#contacttype",
    "href": "02_Pandas_Solution.html#contacttype",
    "title": "Python Solution",
    "section": "",
    "text": "is required and can only be Household or Organization  \n\nSource Table:  - Contacts Table  \nSolution: 1. Create procedure to add new column ContactType\n\ncontacts[['Number', 'CompanyName']]\n\n\n\n\n\n\n\n\nNumber\nCompanyName\n\n\n\n\n0\n653377813-7\n\n\n\n1\n390551098-7\n\n\n\n2\n093004505-X\n\n\n\n3\n729707142-0\nA Company Co.\n\n\n4\n488464926-5\n\n\n\n5\n315297729-8\n\n\n\n6\n848348568-0\n\n\n\n7\n029456846-8\n\n\n\n8\n687119652-8\n\n\n\n9\n739131380-7\n\n\n\n10\n809975531-Y\n\n\n\n\n\n\n\n\n\n\ncontacts['ContactType'] = contacts.apply(lambda x: 'Household' if x['CompanyName'] == '' else 'Organization', axis=1)\n\n\ncontacts[['Number', 'CompanyName', 'ContactType']].head(3)\n\n\n\n\n\n\n\n\nNumber\nCompanyName\nContactType\n\n\n\n\n0\n653377813-7\n\nHousehold\n\n\n1\n390551098-7\n\nHousehold\n\n\n2\n093004505-X\n\nHousehold"
  },
  {
    "objectID": "02_Pandas_Solution.html#postal-code",
    "href": "02_Pandas_Solution.html#postal-code",
    "title": "Python Solution",
    "section": "",
    "text": "if address is present and is US, must be a valid zip code, either 12345 or 12345-1234  \n\nSource Table: - Contacts  \nSolution:  1. Create procedure to remove any postal codees that doesn’t match the approved format from the usps\n\ncontacts['Postal'].head(3)\n\n0    20535-871\n1        89130\n2             \nName: Postal, dtype: object\n\n\n\npostal_code_pattern = '[0-9]{5}(?:-[0-9]{4})?$'\n\n\n\n\nbool(re.match(postal_code_pattern, '32828'))\n\nTrue\n\n\n\nbool(re.match(postal_code_pattern, '328289'))\n\nFalse\n\n\n\nbool(re.match(postal_code_pattern, '3282'))\n\nFalse\n\n\n\nbool(re.match(postal_code_pattern, '32828-237'))\n\nFalse\n\n\n\nbool(re.match(postal_code_pattern, '32828-2379'))\n\nTrue\n\n\n\n\n\n\ncontacts['Postal'] = contacts.Postal.apply(lambda x: x if re.match(postal_code_pattern, x) else '')\n\n\ncontacts['Postal'].head(3)\n\n0         \n1    89130\n2         \nName: Postal, dtype: object"
  },
  {
    "objectID": "02_Pandas_Solution.html#isdeceased",
    "href": "02_Pandas_Solution.html#isdeceased",
    "title": "Python Solution",
    "section": "",
    "text": "can only be TRUE or FALSE  \n\nSource Table: - Contacts  \nSolution:  1. Create procedure to update Deceased to TRUE/FALSE\n\ncontacts.Deceased.head(3)\n\n0    \n1    \n2    \nName: Deceased, dtype: object\n\n\n\ncontacts['Deceased'] = contacts.Deceased.apply(lambda x: True if x == 'Yes' else False)\n\n\ncontacts.Deceased.head(3)\n\n0    False\n1    False\n2    False\nName: Deceased, dtype: bool"
  },
  {
    "objectID": "02_Pandas_Solution.html#gifttype",
    "href": "02_Pandas_Solution.html#gifttype",
    "title": "Python Solution",
    "section": "",
    "text": "Can only be Cash, Check, Credit, Other, or Reversing Transaction  \n\nSource Table: - Gifts  \nSolution:  1. Identify Incorrect Gift Types  2. Create procedure to replace invalid gift types \n\ngifts[['AmountReceived', 'PaymentMethod']].tail(10)\n\n\n\n\n\n\n\n\nAmountReceived\nPaymentMethod\n\n\n\n\n21\n4.21\ncredit card\n\n\n22\n9.28\ncash\n\n\n23\n2.74\nPayPal\n\n\n24\n9.00\nmoney order\n\n\n25\n1.88\ncash\n\n\n26\n-6.76\ncheck\n\n\n27\n7.58\ncredit card\n\n\n28\n5.49\ncash\n\n\n29\n8.93\nmoney order\n\n\n30\n2.62\ncredit card\n\n\n\n\n\n\n\n\ndef clean_payment_type(row):\n    payment_method = ''\n    orginal_payment_method = str(row['PaymentMethod']).lower()\n    \n    if row['AmountReceived'] &lt; 0:\n        payment_method = 'Reversing Transaction'\n    elif re.match('credit', orginal_payment_method):\n        payment_method = 'Credit'\n    elif orginal_payment_method in ['check', 'cash', 'reversing transaction']:\n        payment_method = orginal_payment_method.title()\n    else:\n        payment_method = 'Other'\n\n    return payment_method\n\n\nsource\n\n\n\n clean_payment_type (row)"
  },
  {
    "objectID": "02_Pandas_Solution.html#applying-gifttype-transformation",
    "href": "02_Pandas_Solution.html#applying-gifttype-transformation",
    "title": "Python Solution",
    "section": "",
    "text": "gifts['PaymentMethod'] = gifts.apply(clean_payment_type, axis=1)\n\n\ngifts.PaymentMethod.tail(10)\n\n21                   Credit\n22                     Cash\n23                    Other\n24                    Other\n25                     Cash\n26    Reversing Transaction\n27                   Credit\n28                     Cash\n29                    Other\n30                   Credit\nName: PaymentMethod, dtype: object"
  },
  {
    "objectID": "02_Pandas_Solution.html#creditcardtype",
    "href": "02_Pandas_Solution.html#creditcardtype",
    "title": "Python Solution",
    "section": "",
    "text": "Can only be Visa, Mastercard, AMEX, Discover   Solution:  1. Identify Incorrect Credit Types  2. Create procedure to replace invalid credit types\n\n\ngifts.CreditCardType.unique()\n\narray(['', 'American Ex', 'AMEX', 'Visa', 'Master card', 'Mastercard',\n       'Discover'], dtype=object)\n\n\nCreating functions to validate each of the credit card types\n\nsource\n\n\n\n validate_mastercard (string)\n\n\nsource\n\n\n\n\n validate_amex (string)\n\n\nsource\n\n\n\n\n validate_visa (string)\n\n\nsource\n\n\n\n\n validate_discover (string)\n\n\nsource\n\n\n\n\n validate_credit_card (string)\n\n\nvalidate_credit_card('Amex')\n\n'AMEX'\n\n\n\nvalidate_credit_card('Master Card')\n\n'Mastercard'\n\n\n\nvalidate_credit_card('visa')\n\n'Visa'\n\n\n\nvalidate_credit_card('test')\n\n''\n\n\n\nvalidate_credit_card('Gold card')\n\n''"
  },
  {
    "objectID": "02_Pandas_Solution.html#applying-creditcardtype-transformation",
    "href": "02_Pandas_Solution.html#applying-creditcardtype-transformation",
    "title": "Python Solution",
    "section": "",
    "text": "gifts['CreditCardType'] = gifts.CreditCardType.apply(validate_credit_card)"
  },
  {
    "objectID": "02_Pandas_Solution.html#contact-methods",
    "href": "02_Pandas_Solution.html#contact-methods",
    "title": "Python Solution",
    "section": "Contact Methods",
    "text": "Contact Methods\n\nTable of constituent contact information\n\nMerging Contact and Contact Methods Tables To get ALL the contact information\n\ntemp_contacts = contacts[['Number', 'Phone', 'EMail']].rename(columns={\n    'Number': 'LegacyContactId',\n    'Phone': 'HomePhone',\n    'EMail': 'HomeEmail'\n}).copy()\n\n\ntemp_contact_methods = contact_methods.rename(columns={'DonorNumber':'LegacyContactId'})\n\n\ncontacts_wide = temp_contacts.merge(temp_contact_methods,\n                                how='left',\n                                on='LegacyContactId',\n                                ).sort_values('LegacyContactId')\n\nPivoting the Data, converting the HomePhone, HomeEmail, And Fax values to individual Type : Value pairs\n\ncontacts_v = contacts_wide.melt(id_vars=['LegacyContactId'], value_vars=['HomePhone', 'HomeEmail', 'Fax', 'Phone', 'EMail'], var_name='Type', value_name='Value')\n\nCreating a function to safley check for nan values\n\ndef is_nan(x):\n    try:\n        return np.isnan(x)\n    except TypeError:\n        return False\n\n\nfinal_contact_methods = contacts_v[~((contacts_v.Value == '') | (contacts_v.Value.apply(is_nan)))].reset_index(drop=True).copy()\n\n\ndef clean_contact_type(s):\n    if s == 'Phone':\n        return 'HomePhone'\n    elif s == 'EMail':\n        return 'HomeEmail'\n    else:\n        return s\n\n\nfinal_contact_methods['Type'] = final_contact_methods.Type.apply(clean_contact_type)\n\n\nfinal_contact_methods.drop_duplicates(inplace=True)\n\n\nfinal_contact_methods.sort_values('LegacyContactId').reset_index(drop=True)\n\n\n\n\n\n\n\n\nLegacyContactId\nType\nValue\n\n\n\n\n0\n029456846-8\nHomeEmail\njdoley6@telegraph.co.uk\n\n\n1\n093004505-X\nFax\n818-156-7985\n\n\n2\n093004505-X\nHomePhone\n818-323-9865\n\n\n3\n315297729-8\nHomeEmail\ndmouncey9@cnn.com\n\n\n4\n390551098-7\nHomeEmail\nebenech1@goodreads.com\n\n\n5\n488464926-5\nHomeEmail\nfcastille4@timesonline.co.uk\n\n\n6\n653377813-7\nHomeEmail\nkklumbers@yahoo.com\n\n\n7\n653377813-7\nHomePhone\n832-442-4988\n\n\n8\n687119652-8\nHomeEmail\ncmakepeace7@1688.com\n\n\n9\n739131380-7\nFax\n626-981-3874\n\n\n10\n848348568-0\nHomePhone\n702-844-9524\n\n\n\n\n\n\n\n\n\nfinal_contact_methods.to_csv('data/final_contact_methods.csv', index=False)"
  },
  {
    "objectID": "02_Pandas_Solution.html#contacts",
    "href": "02_Pandas_Solution.html#contacts",
    "title": "Python Solution",
    "section": "Contacts",
    "text": "Contacts\n\nTable of constituent contact information\n\nChecking for any missing contacts\n\ndef is_empty(x):\n    if str(x) == '' or str(x) == 'nan':\n        return True\n    else:\n        return False\n\n\ndef format_string(x):\n    if is_empty(x):\n        return ''\n    else: \n        return x\n\n\ncontacts_wide['HomePhone'] = np.where(contacts_wide['HomePhone'].apply(is_empty), format_string(contacts_wide['Phone']), format_string(contacts_wide['HomePhone']))\ncontacts_wide['HomeEmail'] = np.where(contacts_wide['HomeEmail'].apply(is_empty), format_string(contacts_wide['EMail']), format_string(contacts_wide['HomeEmail']))\n\n\ncontacts_wide = contacts_wide[['LegacyContactId', 'HomePhone', 'HomeEmail']].fillna('').copy()\n\n\ncontacts_wide = contacts_wide[~((contacts_wide.HomePhone == '') & (contacts_wide.HomeEmail == ''))].copy()\n\n\ncontacts = (contacts\n            .drop(['Phone', 'EMail'], axis=1)\n            .merge(contacts_wide,\n                   left_on='Number',\n                   right_on='LegacyContactId',\n                   how='left',\n            )\n            .drop('LegacyContactId', axis=1)\n            )\n\n\ncolumns = [\n    'LegacyContactId', 'LegacyIndividualId', 'ContactType', 'ContactName',\n    'FirstName', \n    'LastName', 'SecondaryLegacyIndividualId', 'SecondaryFirstName',\n    'SecondaryLastName', 'HomePhone', 'HomeEmail', 'Address1', \n    'City', 'State', 'PostalCode', 'IsPrivate', 'IsDeceased',\n    ]\n\n\ncontacts.rename(columns={\n    'Number':'LegacyContactId',\n    'Street': 'Address1',\n    'Postal': 'PostalCode',\n    'Private': 'IsPrivate',\n    'Deceased': 'IsDeceased',\n}, inplace=True)\n\n\nfinal_contacts = contacts[columns].fillna('')\n\n\nfinal_contacts\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyIndividualId\nContactType\nContactName\nFirstName\nLastName\nSecondaryLegacyIndividualId\nSecondaryFirstName\nSecondaryLastName\nHomePhone\nHomeEmail\nAddress1\nCity\nState\nPostalCode\nIsPrivate\nIsDeceased\n\n\n\n\n0\n653377813-7\n0\nHousehold\nKarita & Kelvin Lumbers\nKarita\nLumbers\n1\nKelvin\nLumbers\n832-442-4988\nkklumbers@yahoo.com\n4 Bunting Parkway\nWashington\nDC\n\nTrue\nFalse\n\n\n1\n390551098-7\n2\nHousehold\nHelga Benech\nHelga\nBenech\n\n\n\n\nebenech1@goodreads.com\n48684 Jenifer Way\nLas Vegas\nNV\n89130\nFalse\nFalse\n\n\n2\n093004505-X\n3\nHousehold\nMasha Butt Gow\nMasha\nButt Gow\n\n\n\n818-323-9865\n\n353 Schmedeman Park\nIndianapolis\nIN\n\nFalse\nFalse\n\n\n3\n729707142-0\n4\nOrganization\nCymbre Cross\nCymbre\nCross\n\n\n\n\n\n2055 Lakewood Parkway\nCamden\nNJ\n\nFalse\nFalse\n\n\n4\n488464926-5\n5\nHousehold\nHoyt Castille\nHoyt\nCastille\n\n\n\n\nfcastille4@timesonline.co.uk\n37 8th Trail\nGrand Rapids\nMI\n49560\nFalse\nFalse\n\n\n5\n315297729-8\n6\nHousehold\nBenedict Oscar & Idell Mouncey\nBenedict\nOscar\n7\nIdell\nMouncey\n\ndmouncey9@cnn.com\n4225 Madison Ave\nBoise\nID\n\nFalse\nFalse\n\n\n6\n848348568-0\n8\nHousehold\nMannie Turpin\nMannie\nTurpin\n\n\n\n702-844-9524\n\n\n\nNV\n\nFalse\nTrue\n\n\n7\n029456846-8\n9\nHousehold\nRomy Doley\nRomy\nDoley\n\n\n\n\njdoley6@telegraph.co.uk\n608 Old Shore Alley\nMarietta\nGA\n30066\nFalse\nFalse\n\n\n8\n687119652-8\n10\nHousehold\nRuggiero Makepeace\nRuggiero\nMakepeace\n\n\n\n\ncmakepeace7@1688.com\n15 Sunbrook Center\nOmaha\nNE\n68164\nFalse\nFalse\n\n\n9\n739131380-7\n11\nHousehold\nRosemaria & Rogelio Dimond\nRosemaria\nDimond\n12\nRogelio\nDimond\n\n\n\nJuneau\nAK\n\nFalse\nFalse\n\n\n10\n809975531-Y\n13\nHousehold\nAdeline Shakespeare\nAdeline\nShakespeare\n\n\n\n\n\n\n\n\n\nFalse\nFalse\n\n\n\n\n\n\n\n\n\nfinal_contacts.to_csv('data/final_contacts.csv', index=False)"
  },
  {
    "objectID": "02_Pandas_Solution.html#gifts",
    "href": "02_Pandas_Solution.html#gifts",
    "title": "Python Solution",
    "section": "Gifts",
    "text": "Gifts\n\nTable with gift history\n\n\ncolumns = ['LegacyContactId', 'LegacyGiftId', 'GiftType', 'GiftDate',\n           'GiftAmount', 'Notes', 'CreditCardType', 'Project1Code',\n           'Project2Code', 'LegacyPledgeID']\n\n\ngifts.rename(columns={\n    'DonorNumber': 'LegacyContactId',\n    'PaymentMethod': 'GiftType',\n    'AmountReceived': 'GiftAmount',\n}, inplace=True)\n\n\ngifts[columns]\n\n\n\n\n\n\n\n\nLegacyContactId\nLegacyGiftId\nGiftType\nGiftDate\nGiftAmount\nNotes\nCreditCardType\nProject1Code\nProject2Code\nLegacyPledgeID\n\n\n\n\n0\n848348568-0\n95196378\nOther\n2019-03-04\n4.1500\n\n\n\nNone\n0\n\n\n1\n729707142-0\n95196889\nCheck\n2019-03-05\n2.3648\n\n\nChildSponsorship\nNone\n1\n\n\n2\n687119652-8\n95197689\nCash\n2019-03-07\n1.3100\n\n\n\nNone\n2\n\n\n3\n653377813-7\n95198998\nCredit\n2019-03-10\n2.0400\nIn honor of Mannie Turpin\nAMEX\n\nNone\n3\n\n\n4\n390551098-7\n95198999\nCash\n2019-01-10\n5.8000\n\n\n\nNone\n89752384\n\n\n5\n848348568-0\n95296677\nOther\n2019-03-20\n9.2800\n\n\nGeneral\nReliefFund\n5\n\n\n6\n029456846-8\n95298831\nCheck\n2019-03-24\n5.0000\nACH check #7687\n\n\nNone\n6\n\n\n7\n093004505-X\n95298845\nCheck\n2019-04-09\n4.8300\n\n\n\nNone\n7\n\n\n8\n315297729-8\n95298997\nCheck\n2019-04-12\n7.0000\n\n\nSchoolSupplies2019\nNone\n8\n\n\n9\n809975531-Y\n9\nCredit\n2019-08-14\n8.4800\n\nAMEX\n\nNone\n9\n\n\n10\n739131380-7\n95329966\nCredit\n2019-04-13\n5.8400\n\nVisa\n\nNone\n10\n\n\n11\n739131380-7\n95330011\nOther\n2019-04-13\n7.4500\n\n\n\nNone\n11\n\n\n12\n029456846-8\n95330012\nCheck\n2019-04-17\n8.1300\n\n\nMentorship2023\nNone\n12\n\n\n13\n315297729-8\n95330110\nReversing Transaction\n2019-04-19\n-3.0100\n\n\n\nNone\n13\n\n\n14\n739131380-7\n95330662\nOther\n2019-05-10\n3.4000\n\n\n\nNone\n14\n\n\n15\n687119652-8\n95419562\nOther\n2019-06-04\n5.0700\n\n\n\nNone\n15\n\n\n16\n488464926-5\n95422266\nCash\n2019-06-05\n5.4200\n\n\nGeneralFund\nNone\n16\n\n\n17\n848348568-0\n95485564\nOther\n2019-06-10\n6.8000\n\n\n\nNone\n57398862\n\n\n18\n390551098-7\n95496635\nOther\n2019-06-11\n6.7800\n\n\n\nNone\n18\n\n\n19\n729707142-0\n95497782\nOther\n2019-06-20\n5.2700\n\n\n\nNone\n19\n\n\n20\n315297729-8\n20\nCheck\n2019-06-20\n5.5900\n\n\n\nNone\n65139856\n\n\n21\n390551098-7\n95763575\nCredit\n2019-07-01\n4.2100\n\nMastercard\n\nNone\n21\n\n\n22\n488464926-5\n95798342\nCash\n2019-07-18\n9.2800\n\n\n\nNone\n22\n\n\n23\n848348568-0\n95798343\nOther\n2019-07-01\n2.7400\n\n\n\nNone\n23\n\n\n24\n029456846-8\n95801563\nOther\n2019-08-01\n9.0000\n\n\n\nNone\n24\n\n\n25\n729707142-0\n95801564\nCash\n2019-08-03\n1.8800\n\n\n\nNone\n25\n\n\n26\n687119652-8\n95835492\nReversing Transaction\n2019-08-12\n-6.7600\n\n\n\nNone\n26\n\n\n27\n809975531-Y\n27\nCredit\n2019-08-14\n7.5800\n\nMastercard\nColor run\nChildSponsorship\n27\n\n\n28\n653377813-7\n28\nCash\n2019-08-26\n5.4900\n\n\n\nNone\n28\n\n\n29\n739131380-7\n96638462\nOther\n2019-09-01\n8.9300\n\n\nReliefFund\nNone\n29\n\n\n30\n093004505-X\n96638468\nCredit\n2019-09-06\n2.6200\n\nDiscover\n\nNone\n30\n\n\n\n\n\n\n\n\n\nfinal_gifts = gifts[columns].copy()\n\n\nfinal_gifts.to_csv('data/final_gifts.csv', index=False)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "Virtuous Data Schema, changes that require ETL have been highlighted \n\n\n\n\n\nalternative text\n\n\n\n\n\nI performed ETL of 3 spreadsheets into SQL tables & csv files that match the Virtuous schema  \n\n\nContacts: A table of contacts, with 1 or 2 constituents per row\nGifts: Donations from individual constituents\nContact Methods: Contact information for individual constituents\n\n\n\n\n\nI’ve demonstrated 3 methods of performing the data migraiton  \n\n\nSetup \nMethod 1: SQL \nMethod 2: Python / Pandas \nMethod 3: Generative AI / Chat GPT \n\n\n\n\n\nCSV files generated from the Python ETL process  \n\n\nfinal_contacts\nfinal_gifts\nfinal_contact_methods   The intial datasets are also available in the data folder\n\n\n\n\n\nIdea bananza!\n\n\n\n\nAugust 10th, 2:29 PM EST  \n\n\n\n\nEmail with assignment details\n\n\n\n\n\n\nCompleted: August 10th, 3:13 PM EST  \n\n\n\n\nRough Action Plan\n\n\n\n\n\n\nI got a little carried away  \n\nSometimes I can’t help myself! I love working with data. Finding new & interesting ways to solve problems is something I’m naturally passionate about   The downside? I tend to wander a little too close to the sun…   While this project was simply to migrate the data to tables compatible with the Virtuous schema, I felt a deep desire to do more. To go above & beyond. While I pride myself on adapting to the needs of a team, the desire to grow and change is core to who I am. And I believe it’s a valuable asset to a great team.   I promise to do what’s best for the team.  And I also promise to always push the boundries of what’s possible"
  },
  {
    "objectID": "index.html#summary",
    "href": "index.html#summary",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "I performed ETL of 3 spreadsheets into SQL tables & csv files that match the Virtuous schema  \n\n\nContacts: A table of contacts, with 1 or 2 constituents per row\nGifts: Donations from individual constituents\nContact Methods: Contact information for individual constituents"
  },
  {
    "objectID": "index.html#notebooks",
    "href": "index.html#notebooks",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "I’ve demonstrated 3 methods of performing the data migraiton  \n\n\nSetup \nMethod 1: SQL \nMethod 2: Python / Pandas \nMethod 3: Generative AI / Chat GPT"
  },
  {
    "objectID": "index.html#result",
    "href": "index.html#result",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "CSV files generated from the Python ETL process  \n\n\nfinal_contacts\nfinal_gifts\nfinal_contact_methods   The intial datasets are also available in the data folder"
  },
  {
    "objectID": "index.html#my-approach",
    "href": "index.html#my-approach",
    "title": "Virtuous Interview Exam",
    "section": "",
    "text": "Idea bananza!\n\n\n\n\nAugust 10th, 2:29 PM EST  \n\n\n\n\nEmail with assignment details\n\n\n\n\n\n\nCompleted: August 10th, 3:13 PM EST  \n\n\n\n\nRough Action Plan\n\n\n\n\n\n\nI got a little carried away  \n\nSometimes I can’t help myself! I love working with data. Finding new & interesting ways to solve problems is something I’m naturally passionate about   The downside? I tend to wander a little too close to the sun…   While this project was simply to migrate the data to tables compatible with the Virtuous schema, I felt a deep desire to do more. To go above & beyond. While I pride myself on adapting to the needs of a team, the desire to grow and change is core to who I am. And I believe it’s a valuable asset to a great team.   I promise to do what’s best for the team.  And I also promise to always push the boundries of what’s possible"
  }
]